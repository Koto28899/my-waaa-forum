// Code generated by ent, DO NOT EDIT.

package ent

import (
	"backend/ent/comment"
	"backend/ent/follow"
	"backend/ent/help"
	"backend/ent/notification"
	"backend/ent/post"
	"backend/ent/predicate"
	"backend/ent/reply"
	"backend/ent/role"
	"backend/ent/section"
	"backend/ent/session"
	"backend/ent/star"
	"backend/ent/vote"
	"backend/ent/voteevent"
	"backend/ent/voteoption"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeComment      = "Comment"
	TypeFollow       = "Follow"
	TypeHelp         = "Help"
	TypeNotification = "Notification"
	TypePost         = "Post"
	TypeReply        = "Reply"
	TypeRole         = "Role"
	TypeSection      = "Section"
	TypeSession      = "Session"
	TypeStar         = "Star"
	TypeVote         = "Vote"
	TypeVoteEvent    = "VoteEvent"
	TypeVoteOption   = "VoteOption"
)

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	from_role_id    *int64
	addfrom_role_id *int64
	to_post_id      *int64
	addto_post_id   *int64
	likes_count     *int64
	addlikes_count  *int64
	is_top          *bool
	body            *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Comment, error)
	predicates      []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id int64) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CommentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CommentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CommentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[comment.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CommentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[comment.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CommentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, comment.FieldDeletedAt)
}

// SetFromRoleID sets the "from_role_id" field.
func (m *CommentMutation) SetFromRoleID(i int64) {
	m.from_role_id = &i
	m.addfrom_role_id = nil
}

// FromRoleID returns the value of the "from_role_id" field in the mutation.
func (m *CommentMutation) FromRoleID() (r int64, exists bool) {
	v := m.from_role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromRoleID returns the old "from_role_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldFromRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromRoleID: %w", err)
	}
	return oldValue.FromRoleID, nil
}

// AddFromRoleID adds i to the "from_role_id" field.
func (m *CommentMutation) AddFromRoleID(i int64) {
	if m.addfrom_role_id != nil {
		*m.addfrom_role_id += i
	} else {
		m.addfrom_role_id = &i
	}
}

// AddedFromRoleID returns the value that was added to the "from_role_id" field in this mutation.
func (m *CommentMutation) AddedFromRoleID() (r int64, exists bool) {
	v := m.addfrom_role_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFromRoleID resets all changes to the "from_role_id" field.
func (m *CommentMutation) ResetFromRoleID() {
	m.from_role_id = nil
	m.addfrom_role_id = nil
}

// SetToPostID sets the "to_post_id" field.
func (m *CommentMutation) SetToPostID(i int64) {
	m.to_post_id = &i
	m.addto_post_id = nil
}

// ToPostID returns the value of the "to_post_id" field in the mutation.
func (m *CommentMutation) ToPostID() (r int64, exists bool) {
	v := m.to_post_id
	if v == nil {
		return
	}
	return *v, true
}

// OldToPostID returns the old "to_post_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldToPostID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToPostID: %w", err)
	}
	return oldValue.ToPostID, nil
}

// AddToPostID adds i to the "to_post_id" field.
func (m *CommentMutation) AddToPostID(i int64) {
	if m.addto_post_id != nil {
		*m.addto_post_id += i
	} else {
		m.addto_post_id = &i
	}
}

// AddedToPostID returns the value that was added to the "to_post_id" field in this mutation.
func (m *CommentMutation) AddedToPostID() (r int64, exists bool) {
	v := m.addto_post_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetToPostID resets all changes to the "to_post_id" field.
func (m *CommentMutation) ResetToPostID() {
	m.to_post_id = nil
	m.addto_post_id = nil
}

// SetLikesCount sets the "likes_count" field.
func (m *CommentMutation) SetLikesCount(i int64) {
	m.likes_count = &i
	m.addlikes_count = nil
}

// LikesCount returns the value of the "likes_count" field in the mutation.
func (m *CommentMutation) LikesCount() (r int64, exists bool) {
	v := m.likes_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikesCount returns the old "likes_count" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldLikesCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikesCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikesCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikesCount: %w", err)
	}
	return oldValue.LikesCount, nil
}

// AddLikesCount adds i to the "likes_count" field.
func (m *CommentMutation) AddLikesCount(i int64) {
	if m.addlikes_count != nil {
		*m.addlikes_count += i
	} else {
		m.addlikes_count = &i
	}
}

// AddedLikesCount returns the value that was added to the "likes_count" field in this mutation.
func (m *CommentMutation) AddedLikesCount() (r int64, exists bool) {
	v := m.addlikes_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikesCount resets all changes to the "likes_count" field.
func (m *CommentMutation) ResetLikesCount() {
	m.likes_count = nil
	m.addlikes_count = nil
}

// SetIsTop sets the "is_top" field.
func (m *CommentMutation) SetIsTop(b bool) {
	m.is_top = &b
}

// IsTop returns the value of the "is_top" field in the mutation.
func (m *CommentMutation) IsTop() (r bool, exists bool) {
	v := m.is_top
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTop returns the old "is_top" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldIsTop(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTop is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTop requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTop: %w", err)
	}
	return oldValue.IsTop, nil
}

// ResetIsTop resets all changes to the "is_top" field.
func (m *CommentMutation) ResetIsTop() {
	m.is_top = nil
}

// SetBody sets the "body" field.
func (m *CommentMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *CommentMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *CommentMutation) ResetBody() {
	m.body = nil
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, comment.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, comment.FieldDeletedAt)
	}
	if m.from_role_id != nil {
		fields = append(fields, comment.FieldFromRoleID)
	}
	if m.to_post_id != nil {
		fields = append(fields, comment.FieldToPostID)
	}
	if m.likes_count != nil {
		fields = append(fields, comment.FieldLikesCount)
	}
	if m.is_top != nil {
		fields = append(fields, comment.FieldIsTop)
	}
	if m.body != nil {
		fields = append(fields, comment.FieldBody)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	case comment.FieldUpdatedAt:
		return m.UpdatedAt()
	case comment.FieldDeletedAt:
		return m.DeletedAt()
	case comment.FieldFromRoleID:
		return m.FromRoleID()
	case comment.FieldToPostID:
		return m.ToPostID()
	case comment.FieldLikesCount:
		return m.LikesCount()
	case comment.FieldIsTop:
		return m.IsTop()
	case comment.FieldBody:
		return m.Body()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case comment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case comment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case comment.FieldFromRoleID:
		return m.OldFromRoleID(ctx)
	case comment.FieldToPostID:
		return m.OldToPostID(ctx)
	case comment.FieldLikesCount:
		return m.OldLikesCount(ctx)
	case comment.FieldIsTop:
		return m.OldIsTop(ctx)
	case comment.FieldBody:
		return m.OldBody(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case comment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case comment.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case comment.FieldFromRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromRoleID(v)
		return nil
	case comment.FieldToPostID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToPostID(v)
		return nil
	case comment.FieldLikesCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikesCount(v)
		return nil
	case comment.FieldIsTop:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTop(v)
		return nil
	case comment.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	var fields []string
	if m.addfrom_role_id != nil {
		fields = append(fields, comment.FieldFromRoleID)
	}
	if m.addto_post_id != nil {
		fields = append(fields, comment.FieldToPostID)
	}
	if m.addlikes_count != nil {
		fields = append(fields, comment.FieldLikesCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldFromRoleID:
		return m.AddedFromRoleID()
	case comment.FieldToPostID:
		return m.AddedToPostID()
	case comment.FieldLikesCount:
		return m.AddedLikesCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comment.FieldFromRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromRoleID(v)
		return nil
	case comment.FieldToPostID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToPostID(v)
		return nil
	case comment.FieldLikesCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikesCount(v)
		return nil
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comment.FieldDeletedAt) {
		fields = append(fields, comment.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	switch name {
	case comment.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case comment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case comment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case comment.FieldFromRoleID:
		m.ResetFromRoleID()
		return nil
	case comment.FieldToPostID:
		m.ResetToPostID()
		return nil
	case comment.FieldLikesCount:
		m.ResetLikesCount()
		return nil
	case comment.FieldIsTop:
		m.ResetIsTop()
		return nil
	case comment.FieldBody:
		m.ResetBody()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Comment edge %s", name)
}

// FollowMutation represents an operation that mutates the Follow nodes in the graph.
type FollowMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	from_role_id    *int64
	addfrom_role_id *int64
	to_role_id      *int64
	addto_role_id   *int64
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Follow, error)
	predicates      []predicate.Follow
}

var _ ent.Mutation = (*FollowMutation)(nil)

// followOption allows management of the mutation configuration using functional options.
type followOption func(*FollowMutation)

// newFollowMutation creates new mutation for the Follow entity.
func newFollowMutation(c config, op Op, opts ...followOption) *FollowMutation {
	m := &FollowMutation{
		config:        c,
		op:            op,
		typ:           TypeFollow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFollowID sets the ID field of the mutation.
func withFollowID(id int64) followOption {
	return func(m *FollowMutation) {
		var (
			err   error
			once  sync.Once
			value *Follow
		)
		m.oldValue = func(ctx context.Context) (*Follow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Follow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFollow sets the old Follow of the mutation.
func withFollow(node *Follow) followOption {
	return func(m *FollowMutation) {
		m.oldValue = func(context.Context) (*Follow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FollowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FollowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Follow entities.
func (m *FollowMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FollowMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FollowMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Follow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FollowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FollowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Follow entity.
// If the Follow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FollowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FollowMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FollowMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Follow entity.
// If the Follow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FollowMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FollowMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FollowMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Follow entity.
// If the Follow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FollowMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[follow.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FollowMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[follow.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FollowMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, follow.FieldDeletedAt)
}

// SetFromRoleID sets the "from_role_id" field.
func (m *FollowMutation) SetFromRoleID(i int64) {
	m.from_role_id = &i
	m.addfrom_role_id = nil
}

// FromRoleID returns the value of the "from_role_id" field in the mutation.
func (m *FollowMutation) FromRoleID() (r int64, exists bool) {
	v := m.from_role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromRoleID returns the old "from_role_id" field's value of the Follow entity.
// If the Follow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowMutation) OldFromRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromRoleID: %w", err)
	}
	return oldValue.FromRoleID, nil
}

// AddFromRoleID adds i to the "from_role_id" field.
func (m *FollowMutation) AddFromRoleID(i int64) {
	if m.addfrom_role_id != nil {
		*m.addfrom_role_id += i
	} else {
		m.addfrom_role_id = &i
	}
}

// AddedFromRoleID returns the value that was added to the "from_role_id" field in this mutation.
func (m *FollowMutation) AddedFromRoleID() (r int64, exists bool) {
	v := m.addfrom_role_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFromRoleID resets all changes to the "from_role_id" field.
func (m *FollowMutation) ResetFromRoleID() {
	m.from_role_id = nil
	m.addfrom_role_id = nil
}

// SetToRoleID sets the "to_role_id" field.
func (m *FollowMutation) SetToRoleID(i int64) {
	m.to_role_id = &i
	m.addto_role_id = nil
}

// ToRoleID returns the value of the "to_role_id" field in the mutation.
func (m *FollowMutation) ToRoleID() (r int64, exists bool) {
	v := m.to_role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldToRoleID returns the old "to_role_id" field's value of the Follow entity.
// If the Follow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowMutation) OldToRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToRoleID: %w", err)
	}
	return oldValue.ToRoleID, nil
}

// AddToRoleID adds i to the "to_role_id" field.
func (m *FollowMutation) AddToRoleID(i int64) {
	if m.addto_role_id != nil {
		*m.addto_role_id += i
	} else {
		m.addto_role_id = &i
	}
}

// AddedToRoleID returns the value that was added to the "to_role_id" field in this mutation.
func (m *FollowMutation) AddedToRoleID() (r int64, exists bool) {
	v := m.addto_role_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetToRoleID resets all changes to the "to_role_id" field.
func (m *FollowMutation) ResetToRoleID() {
	m.to_role_id = nil
	m.addto_role_id = nil
}

// Where appends a list predicates to the FollowMutation builder.
func (m *FollowMutation) Where(ps ...predicate.Follow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FollowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FollowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Follow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FollowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FollowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Follow).
func (m *FollowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FollowMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, follow.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, follow.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, follow.FieldDeletedAt)
	}
	if m.from_role_id != nil {
		fields = append(fields, follow.FieldFromRoleID)
	}
	if m.to_role_id != nil {
		fields = append(fields, follow.FieldToRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FollowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case follow.FieldCreatedAt:
		return m.CreatedAt()
	case follow.FieldUpdatedAt:
		return m.UpdatedAt()
	case follow.FieldDeletedAt:
		return m.DeletedAt()
	case follow.FieldFromRoleID:
		return m.FromRoleID()
	case follow.FieldToRoleID:
		return m.ToRoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FollowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case follow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case follow.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case follow.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case follow.FieldFromRoleID:
		return m.OldFromRoleID(ctx)
	case follow.FieldToRoleID:
		return m.OldToRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown Follow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FollowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case follow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case follow.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case follow.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case follow.FieldFromRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromRoleID(v)
		return nil
	case follow.FieldToRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown Follow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FollowMutation) AddedFields() []string {
	var fields []string
	if m.addfrom_role_id != nil {
		fields = append(fields, follow.FieldFromRoleID)
	}
	if m.addto_role_id != nil {
		fields = append(fields, follow.FieldToRoleID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FollowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case follow.FieldFromRoleID:
		return m.AddedFromRoleID()
	case follow.FieldToRoleID:
		return m.AddedToRoleID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FollowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case follow.FieldFromRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromRoleID(v)
		return nil
	case follow.FieldToRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown Follow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FollowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(follow.FieldDeletedAt) {
		fields = append(fields, follow.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FollowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FollowMutation) ClearField(name string) error {
	switch name {
	case follow.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Follow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FollowMutation) ResetField(name string) error {
	switch name {
	case follow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case follow.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case follow.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case follow.FieldFromRoleID:
		m.ResetFromRoleID()
		return nil
	case follow.FieldToRoleID:
		m.ResetToRoleID()
		return nil
	}
	return fmt.Errorf("unknown Follow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FollowMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FollowMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FollowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FollowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FollowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FollowMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FollowMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Follow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FollowMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Follow edge %s", name)
}

// HelpMutation represents an operation that mutates the Help nodes in the graph.
type HelpMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	from_post_id        *int64
	addfrom_post_id     *int64
	adopt_comment_id    *int64
	addadopt_comment_id *int64
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*Help, error)
	predicates          []predicate.Help
}

var _ ent.Mutation = (*HelpMutation)(nil)

// helpOption allows management of the mutation configuration using functional options.
type helpOption func(*HelpMutation)

// newHelpMutation creates new mutation for the Help entity.
func newHelpMutation(c config, op Op, opts ...helpOption) *HelpMutation {
	m := &HelpMutation{
		config:        c,
		op:            op,
		typ:           TypeHelp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHelpID sets the ID field of the mutation.
func withHelpID(id int64) helpOption {
	return func(m *HelpMutation) {
		var (
			err   error
			once  sync.Once
			value *Help
		)
		m.oldValue = func(ctx context.Context) (*Help, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Help.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHelp sets the old Help of the mutation.
func withHelp(node *Help) helpOption {
	return func(m *HelpMutation) {
		m.oldValue = func(context.Context) (*Help, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HelpMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HelpMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Help entities.
func (m *HelpMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HelpMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HelpMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Help.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HelpMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HelpMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Help entity.
// If the Help object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HelpMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HelpMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HelpMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HelpMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Help entity.
// If the Help object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HelpMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HelpMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *HelpMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *HelpMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Help entity.
// If the Help object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HelpMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *HelpMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[help.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *HelpMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[help.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *HelpMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, help.FieldDeletedAt)
}

// SetFromPostID sets the "from_post_id" field.
func (m *HelpMutation) SetFromPostID(i int64) {
	m.from_post_id = &i
	m.addfrom_post_id = nil
}

// FromPostID returns the value of the "from_post_id" field in the mutation.
func (m *HelpMutation) FromPostID() (r int64, exists bool) {
	v := m.from_post_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromPostID returns the old "from_post_id" field's value of the Help entity.
// If the Help object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HelpMutation) OldFromPostID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromPostID: %w", err)
	}
	return oldValue.FromPostID, nil
}

// AddFromPostID adds i to the "from_post_id" field.
func (m *HelpMutation) AddFromPostID(i int64) {
	if m.addfrom_post_id != nil {
		*m.addfrom_post_id += i
	} else {
		m.addfrom_post_id = &i
	}
}

// AddedFromPostID returns the value that was added to the "from_post_id" field in this mutation.
func (m *HelpMutation) AddedFromPostID() (r int64, exists bool) {
	v := m.addfrom_post_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFromPostID resets all changes to the "from_post_id" field.
func (m *HelpMutation) ResetFromPostID() {
	m.from_post_id = nil
	m.addfrom_post_id = nil
}

// SetAdoptCommentID sets the "adopt_comment_id" field.
func (m *HelpMutation) SetAdoptCommentID(i int64) {
	m.adopt_comment_id = &i
	m.addadopt_comment_id = nil
}

// AdoptCommentID returns the value of the "adopt_comment_id" field in the mutation.
func (m *HelpMutation) AdoptCommentID() (r int64, exists bool) {
	v := m.adopt_comment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAdoptCommentID returns the old "adopt_comment_id" field's value of the Help entity.
// If the Help object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HelpMutation) OldAdoptCommentID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdoptCommentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdoptCommentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdoptCommentID: %w", err)
	}
	return oldValue.AdoptCommentID, nil
}

// AddAdoptCommentID adds i to the "adopt_comment_id" field.
func (m *HelpMutation) AddAdoptCommentID(i int64) {
	if m.addadopt_comment_id != nil {
		*m.addadopt_comment_id += i
	} else {
		m.addadopt_comment_id = &i
	}
}

// AddedAdoptCommentID returns the value that was added to the "adopt_comment_id" field in this mutation.
func (m *HelpMutation) AddedAdoptCommentID() (r int64, exists bool) {
	v := m.addadopt_comment_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAdoptCommentID clears the value of the "adopt_comment_id" field.
func (m *HelpMutation) ClearAdoptCommentID() {
	m.adopt_comment_id = nil
	m.addadopt_comment_id = nil
	m.clearedFields[help.FieldAdoptCommentID] = struct{}{}
}

// AdoptCommentIDCleared returns if the "adopt_comment_id" field was cleared in this mutation.
func (m *HelpMutation) AdoptCommentIDCleared() bool {
	_, ok := m.clearedFields[help.FieldAdoptCommentID]
	return ok
}

// ResetAdoptCommentID resets all changes to the "adopt_comment_id" field.
func (m *HelpMutation) ResetAdoptCommentID() {
	m.adopt_comment_id = nil
	m.addadopt_comment_id = nil
	delete(m.clearedFields, help.FieldAdoptCommentID)
}

// Where appends a list predicates to the HelpMutation builder.
func (m *HelpMutation) Where(ps ...predicate.Help) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HelpMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HelpMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Help, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HelpMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HelpMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Help).
func (m *HelpMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HelpMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, help.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, help.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, help.FieldDeletedAt)
	}
	if m.from_post_id != nil {
		fields = append(fields, help.FieldFromPostID)
	}
	if m.adopt_comment_id != nil {
		fields = append(fields, help.FieldAdoptCommentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HelpMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case help.FieldCreatedAt:
		return m.CreatedAt()
	case help.FieldUpdatedAt:
		return m.UpdatedAt()
	case help.FieldDeletedAt:
		return m.DeletedAt()
	case help.FieldFromPostID:
		return m.FromPostID()
	case help.FieldAdoptCommentID:
		return m.AdoptCommentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HelpMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case help.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case help.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case help.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case help.FieldFromPostID:
		return m.OldFromPostID(ctx)
	case help.FieldAdoptCommentID:
		return m.OldAdoptCommentID(ctx)
	}
	return nil, fmt.Errorf("unknown Help field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HelpMutation) SetField(name string, value ent.Value) error {
	switch name {
	case help.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case help.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case help.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case help.FieldFromPostID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromPostID(v)
		return nil
	case help.FieldAdoptCommentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdoptCommentID(v)
		return nil
	}
	return fmt.Errorf("unknown Help field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HelpMutation) AddedFields() []string {
	var fields []string
	if m.addfrom_post_id != nil {
		fields = append(fields, help.FieldFromPostID)
	}
	if m.addadopt_comment_id != nil {
		fields = append(fields, help.FieldAdoptCommentID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HelpMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case help.FieldFromPostID:
		return m.AddedFromPostID()
	case help.FieldAdoptCommentID:
		return m.AddedAdoptCommentID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HelpMutation) AddField(name string, value ent.Value) error {
	switch name {
	case help.FieldFromPostID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromPostID(v)
		return nil
	case help.FieldAdoptCommentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdoptCommentID(v)
		return nil
	}
	return fmt.Errorf("unknown Help numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HelpMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(help.FieldDeletedAt) {
		fields = append(fields, help.FieldDeletedAt)
	}
	if m.FieldCleared(help.FieldAdoptCommentID) {
		fields = append(fields, help.FieldAdoptCommentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HelpMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HelpMutation) ClearField(name string) error {
	switch name {
	case help.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case help.FieldAdoptCommentID:
		m.ClearAdoptCommentID()
		return nil
	}
	return fmt.Errorf("unknown Help nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HelpMutation) ResetField(name string) error {
	switch name {
	case help.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case help.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case help.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case help.FieldFromPostID:
		m.ResetFromPostID()
		return nil
	case help.FieldAdoptCommentID:
		m.ResetAdoptCommentID()
		return nil
	}
	return fmt.Errorf("unknown Help field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HelpMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HelpMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HelpMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HelpMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HelpMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HelpMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HelpMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Help unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HelpMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Help edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	notification_type *notification.NotificationType
	from_role_id      *int64
	addfrom_role_id   *int64
	secne_type        *notification.SecneType
	sence_id          *int64
	addsence_id       *int64
	to_role_id        *int64
	addto_role_id     *int64
	is_checked        *bool
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Notification, error)
	predicates        []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id int64) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notification entities.
func (m *NotificationMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NotificationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NotificationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NotificationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[notification.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NotificationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[notification.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NotificationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, notification.FieldDeletedAt)
}

// SetNotificationType sets the "notification_type" field.
func (m *NotificationMutation) SetNotificationType(nt notification.NotificationType) {
	m.notification_type = &nt
}

// NotificationType returns the value of the "notification_type" field in the mutation.
func (m *NotificationMutation) NotificationType() (r notification.NotificationType, exists bool) {
	v := m.notification_type
	if v == nil {
		return
	}
	return *v, true
}

// OldNotificationType returns the old "notification_type" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldNotificationType(ctx context.Context) (v notification.NotificationType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotificationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotificationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotificationType: %w", err)
	}
	return oldValue.NotificationType, nil
}

// ResetNotificationType resets all changes to the "notification_type" field.
func (m *NotificationMutation) ResetNotificationType() {
	m.notification_type = nil
}

// SetFromRoleID sets the "from_role_id" field.
func (m *NotificationMutation) SetFromRoleID(i int64) {
	m.from_role_id = &i
	m.addfrom_role_id = nil
}

// FromRoleID returns the value of the "from_role_id" field in the mutation.
func (m *NotificationMutation) FromRoleID() (r int64, exists bool) {
	v := m.from_role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromRoleID returns the old "from_role_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldFromRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromRoleID: %w", err)
	}
	return oldValue.FromRoleID, nil
}

// AddFromRoleID adds i to the "from_role_id" field.
func (m *NotificationMutation) AddFromRoleID(i int64) {
	if m.addfrom_role_id != nil {
		*m.addfrom_role_id += i
	} else {
		m.addfrom_role_id = &i
	}
}

// AddedFromRoleID returns the value that was added to the "from_role_id" field in this mutation.
func (m *NotificationMutation) AddedFromRoleID() (r int64, exists bool) {
	v := m.addfrom_role_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFromRoleID resets all changes to the "from_role_id" field.
func (m *NotificationMutation) ResetFromRoleID() {
	m.from_role_id = nil
	m.addfrom_role_id = nil
}

// SetSecneType sets the "secne_type" field.
func (m *NotificationMutation) SetSecneType(nt notification.SecneType) {
	m.secne_type = &nt
}

// SecneType returns the value of the "secne_type" field in the mutation.
func (m *NotificationMutation) SecneType() (r notification.SecneType, exists bool) {
	v := m.secne_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSecneType returns the old "secne_type" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldSecneType(ctx context.Context) (v notification.SecneType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecneType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecneType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecneType: %w", err)
	}
	return oldValue.SecneType, nil
}

// ResetSecneType resets all changes to the "secne_type" field.
func (m *NotificationMutation) ResetSecneType() {
	m.secne_type = nil
}

// SetSenceID sets the "sence_id" field.
func (m *NotificationMutation) SetSenceID(i int64) {
	m.sence_id = &i
	m.addsence_id = nil
}

// SenceID returns the value of the "sence_id" field in the mutation.
func (m *NotificationMutation) SenceID() (r int64, exists bool) {
	v := m.sence_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSenceID returns the old "sence_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldSenceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenceID: %w", err)
	}
	return oldValue.SenceID, nil
}

// AddSenceID adds i to the "sence_id" field.
func (m *NotificationMutation) AddSenceID(i int64) {
	if m.addsence_id != nil {
		*m.addsence_id += i
	} else {
		m.addsence_id = &i
	}
}

// AddedSenceID returns the value that was added to the "sence_id" field in this mutation.
func (m *NotificationMutation) AddedSenceID() (r int64, exists bool) {
	v := m.addsence_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSenceID resets all changes to the "sence_id" field.
func (m *NotificationMutation) ResetSenceID() {
	m.sence_id = nil
	m.addsence_id = nil
}

// SetToRoleID sets the "to_role_id" field.
func (m *NotificationMutation) SetToRoleID(i int64) {
	m.to_role_id = &i
	m.addto_role_id = nil
}

// ToRoleID returns the value of the "to_role_id" field in the mutation.
func (m *NotificationMutation) ToRoleID() (r int64, exists bool) {
	v := m.to_role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldToRoleID returns the old "to_role_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldToRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToRoleID: %w", err)
	}
	return oldValue.ToRoleID, nil
}

// AddToRoleID adds i to the "to_role_id" field.
func (m *NotificationMutation) AddToRoleID(i int64) {
	if m.addto_role_id != nil {
		*m.addto_role_id += i
	} else {
		m.addto_role_id = &i
	}
}

// AddedToRoleID returns the value that was added to the "to_role_id" field in this mutation.
func (m *NotificationMutation) AddedToRoleID() (r int64, exists bool) {
	v := m.addto_role_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetToRoleID resets all changes to the "to_role_id" field.
func (m *NotificationMutation) ResetToRoleID() {
	m.to_role_id = nil
	m.addto_role_id = nil
}

// SetIsChecked sets the "is_checked" field.
func (m *NotificationMutation) SetIsChecked(b bool) {
	m.is_checked = &b
}

// IsChecked returns the value of the "is_checked" field in the mutation.
func (m *NotificationMutation) IsChecked() (r bool, exists bool) {
	v := m.is_checked
	if v == nil {
		return
	}
	return *v, true
}

// OldIsChecked returns the old "is_checked" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldIsChecked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsChecked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsChecked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsChecked: %w", err)
	}
	return oldValue.IsChecked, nil
}

// ResetIsChecked resets all changes to the "is_checked" field.
func (m *NotificationMutation) ResetIsChecked() {
	m.is_checked = nil
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, notification.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notification.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, notification.FieldDeletedAt)
	}
	if m.notification_type != nil {
		fields = append(fields, notification.FieldNotificationType)
	}
	if m.from_role_id != nil {
		fields = append(fields, notification.FieldFromRoleID)
	}
	if m.secne_type != nil {
		fields = append(fields, notification.FieldSecneType)
	}
	if m.sence_id != nil {
		fields = append(fields, notification.FieldSenceID)
	}
	if m.to_role_id != nil {
		fields = append(fields, notification.FieldToRoleID)
	}
	if m.is_checked != nil {
		fields = append(fields, notification.FieldIsChecked)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldCreatedAt:
		return m.CreatedAt()
	case notification.FieldUpdatedAt:
		return m.UpdatedAt()
	case notification.FieldDeletedAt:
		return m.DeletedAt()
	case notification.FieldNotificationType:
		return m.NotificationType()
	case notification.FieldFromRoleID:
		return m.FromRoleID()
	case notification.FieldSecneType:
		return m.SecneType()
	case notification.FieldSenceID:
		return m.SenceID()
	case notification.FieldToRoleID:
		return m.ToRoleID()
	case notification.FieldIsChecked:
		return m.IsChecked()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notification.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notification.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case notification.FieldNotificationType:
		return m.OldNotificationType(ctx)
	case notification.FieldFromRoleID:
		return m.OldFromRoleID(ctx)
	case notification.FieldSecneType:
		return m.OldSecneType(ctx)
	case notification.FieldSenceID:
		return m.OldSenceID(ctx)
	case notification.FieldToRoleID:
		return m.OldToRoleID(ctx)
	case notification.FieldIsChecked:
		return m.OldIsChecked(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notification.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notification.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case notification.FieldNotificationType:
		v, ok := value.(notification.NotificationType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotificationType(v)
		return nil
	case notification.FieldFromRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromRoleID(v)
		return nil
	case notification.FieldSecneType:
		v, ok := value.(notification.SecneType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecneType(v)
		return nil
	case notification.FieldSenceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenceID(v)
		return nil
	case notification.FieldToRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToRoleID(v)
		return nil
	case notification.FieldIsChecked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsChecked(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	var fields []string
	if m.addfrom_role_id != nil {
		fields = append(fields, notification.FieldFromRoleID)
	}
	if m.addsence_id != nil {
		fields = append(fields, notification.FieldSenceID)
	}
	if m.addto_role_id != nil {
		fields = append(fields, notification.FieldToRoleID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldFromRoleID:
		return m.AddedFromRoleID()
	case notification.FieldSenceID:
		return m.AddedSenceID()
	case notification.FieldToRoleID:
		return m.AddedToRoleID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case notification.FieldFromRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromRoleID(v)
		return nil
	case notification.FieldSenceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSenceID(v)
		return nil
	case notification.FieldToRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notification.FieldDeletedAt) {
		fields = append(fields, notification.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	switch name {
	case notification.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notification.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notification.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case notification.FieldNotificationType:
		m.ResetNotificationType()
		return nil
	case notification.FieldFromRoleID:
		m.ResetFromRoleID()
		return nil
	case notification.FieldSecneType:
		m.ResetSecneType()
		return nil
	case notification.FieldSenceID:
		m.ResetSenceID()
		return nil
	case notification.FieldToRoleID:
		m.ResetToRoleID()
		return nil
	case notification.FieldIsChecked:
		m.ResetIsChecked()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Notification edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	from_role_id     *int64
	addfrom_role_id  *int64
	to_section_id    *int64
	addto_section_id *int64
	likes_count      *int64
	addlikes_count   *int64
	is_top           *bool
	is_highlight     *bool
	title            *string
	body             *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Post, error)
	predicates       []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id int64) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Post entities.
func (m *PostMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Post.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PostMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PostMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PostMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[post.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PostMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[post.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PostMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, post.FieldDeletedAt)
}

// SetFromRoleID sets the "from_role_id" field.
func (m *PostMutation) SetFromRoleID(i int64) {
	m.from_role_id = &i
	m.addfrom_role_id = nil
}

// FromRoleID returns the value of the "from_role_id" field in the mutation.
func (m *PostMutation) FromRoleID() (r int64, exists bool) {
	v := m.from_role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromRoleID returns the old "from_role_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldFromRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromRoleID: %w", err)
	}
	return oldValue.FromRoleID, nil
}

// AddFromRoleID adds i to the "from_role_id" field.
func (m *PostMutation) AddFromRoleID(i int64) {
	if m.addfrom_role_id != nil {
		*m.addfrom_role_id += i
	} else {
		m.addfrom_role_id = &i
	}
}

// AddedFromRoleID returns the value that was added to the "from_role_id" field in this mutation.
func (m *PostMutation) AddedFromRoleID() (r int64, exists bool) {
	v := m.addfrom_role_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFromRoleID resets all changes to the "from_role_id" field.
func (m *PostMutation) ResetFromRoleID() {
	m.from_role_id = nil
	m.addfrom_role_id = nil
}

// SetToSectionID sets the "to_section_id" field.
func (m *PostMutation) SetToSectionID(i int64) {
	m.to_section_id = &i
	m.addto_section_id = nil
}

// ToSectionID returns the value of the "to_section_id" field in the mutation.
func (m *PostMutation) ToSectionID() (r int64, exists bool) {
	v := m.to_section_id
	if v == nil {
		return
	}
	return *v, true
}

// OldToSectionID returns the old "to_section_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldToSectionID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToSectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToSectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToSectionID: %w", err)
	}
	return oldValue.ToSectionID, nil
}

// AddToSectionID adds i to the "to_section_id" field.
func (m *PostMutation) AddToSectionID(i int64) {
	if m.addto_section_id != nil {
		*m.addto_section_id += i
	} else {
		m.addto_section_id = &i
	}
}

// AddedToSectionID returns the value that was added to the "to_section_id" field in this mutation.
func (m *PostMutation) AddedToSectionID() (r int64, exists bool) {
	v := m.addto_section_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetToSectionID resets all changes to the "to_section_id" field.
func (m *PostMutation) ResetToSectionID() {
	m.to_section_id = nil
	m.addto_section_id = nil
}

// SetLikesCount sets the "likes_count" field.
func (m *PostMutation) SetLikesCount(i int64) {
	m.likes_count = &i
	m.addlikes_count = nil
}

// LikesCount returns the value of the "likes_count" field in the mutation.
func (m *PostMutation) LikesCount() (r int64, exists bool) {
	v := m.likes_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikesCount returns the old "likes_count" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldLikesCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikesCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikesCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikesCount: %w", err)
	}
	return oldValue.LikesCount, nil
}

// AddLikesCount adds i to the "likes_count" field.
func (m *PostMutation) AddLikesCount(i int64) {
	if m.addlikes_count != nil {
		*m.addlikes_count += i
	} else {
		m.addlikes_count = &i
	}
}

// AddedLikesCount returns the value that was added to the "likes_count" field in this mutation.
func (m *PostMutation) AddedLikesCount() (r int64, exists bool) {
	v := m.addlikes_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikesCount resets all changes to the "likes_count" field.
func (m *PostMutation) ResetLikesCount() {
	m.likes_count = nil
	m.addlikes_count = nil
}

// SetIsTop sets the "is_top" field.
func (m *PostMutation) SetIsTop(b bool) {
	m.is_top = &b
}

// IsTop returns the value of the "is_top" field in the mutation.
func (m *PostMutation) IsTop() (r bool, exists bool) {
	v := m.is_top
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTop returns the old "is_top" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsTop(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTop is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTop requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTop: %w", err)
	}
	return oldValue.IsTop, nil
}

// ResetIsTop resets all changes to the "is_top" field.
func (m *PostMutation) ResetIsTop() {
	m.is_top = nil
}

// SetIsHighlight sets the "is_highlight" field.
func (m *PostMutation) SetIsHighlight(b bool) {
	m.is_highlight = &b
}

// IsHighlight returns the value of the "is_highlight" field in the mutation.
func (m *PostMutation) IsHighlight() (r bool, exists bool) {
	v := m.is_highlight
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHighlight returns the old "is_highlight" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsHighlight(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHighlight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHighlight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHighlight: %w", err)
	}
	return oldValue.IsHighlight, nil
}

// ResetIsHighlight resets all changes to the "is_highlight" field.
func (m *PostMutation) ResetIsHighlight() {
	m.is_highlight = nil
}

// SetTitle sets the "title" field.
func (m *PostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PostMutation) ResetTitle() {
	m.title = nil
}

// SetBody sets the "body" field.
func (m *PostMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *PostMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *PostMutation) ResetBody() {
	m.body = nil
}

// Where appends a list predicates to the PostMutation builder.
func (m *PostMutation) Where(ps ...predicate.Post) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Post, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, post.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, post.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, post.FieldDeletedAt)
	}
	if m.from_role_id != nil {
		fields = append(fields, post.FieldFromRoleID)
	}
	if m.to_section_id != nil {
		fields = append(fields, post.FieldToSectionID)
	}
	if m.likes_count != nil {
		fields = append(fields, post.FieldLikesCount)
	}
	if m.is_top != nil {
		fields = append(fields, post.FieldIsTop)
	}
	if m.is_highlight != nil {
		fields = append(fields, post.FieldIsHighlight)
	}
	if m.title != nil {
		fields = append(fields, post.FieldTitle)
	}
	if m.body != nil {
		fields = append(fields, post.FieldBody)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldCreatedAt:
		return m.CreatedAt()
	case post.FieldUpdatedAt:
		return m.UpdatedAt()
	case post.FieldDeletedAt:
		return m.DeletedAt()
	case post.FieldFromRoleID:
		return m.FromRoleID()
	case post.FieldToSectionID:
		return m.ToSectionID()
	case post.FieldLikesCount:
		return m.LikesCount()
	case post.FieldIsTop:
		return m.IsTop()
	case post.FieldIsHighlight:
		return m.IsHighlight()
	case post.FieldTitle:
		return m.Title()
	case post.FieldBody:
		return m.Body()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case post.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case post.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case post.FieldFromRoleID:
		return m.OldFromRoleID(ctx)
	case post.FieldToSectionID:
		return m.OldToSectionID(ctx)
	case post.FieldLikesCount:
		return m.OldLikesCount(ctx)
	case post.FieldIsTop:
		return m.OldIsTop(ctx)
	case post.FieldIsHighlight:
		return m.OldIsHighlight(ctx)
	case post.FieldTitle:
		return m.OldTitle(ctx)
	case post.FieldBody:
		return m.OldBody(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case post.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case post.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case post.FieldFromRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromRoleID(v)
		return nil
	case post.FieldToSectionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToSectionID(v)
		return nil
	case post.FieldLikesCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikesCount(v)
		return nil
	case post.FieldIsTop:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTop(v)
		return nil
	case post.FieldIsHighlight:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHighlight(v)
		return nil
	case post.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case post.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	var fields []string
	if m.addfrom_role_id != nil {
		fields = append(fields, post.FieldFromRoleID)
	}
	if m.addto_section_id != nil {
		fields = append(fields, post.FieldToSectionID)
	}
	if m.addlikes_count != nil {
		fields = append(fields, post.FieldLikesCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case post.FieldFromRoleID:
		return m.AddedFromRoleID()
	case post.FieldToSectionID:
		return m.AddedToSectionID()
	case post.FieldLikesCount:
		return m.AddedLikesCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case post.FieldFromRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromRoleID(v)
		return nil
	case post.FieldToSectionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToSectionID(v)
		return nil
	case post.FieldLikesCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikesCount(v)
		return nil
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(post.FieldDeletedAt) {
		fields = append(fields, post.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	switch name {
	case post.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case post.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case post.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case post.FieldFromRoleID:
		m.ResetFromRoleID()
		return nil
	case post.FieldToSectionID:
		m.ResetToSectionID()
		return nil
	case post.FieldLikesCount:
		m.ResetLikesCount()
		return nil
	case post.FieldIsTop:
		m.ResetIsTop()
		return nil
	case post.FieldIsHighlight:
		m.ResetIsHighlight()
		return nil
	case post.FieldTitle:
		m.ResetTitle()
		return nil
	case post.FieldBody:
		m.ResetBody()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Post edge %s", name)
}

// ReplyMutation represents an operation that mutates the Reply nodes in the graph.
type ReplyMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	from_role_id    *int64
	addfrom_role_id *int64
	to_post_id      *int64
	addto_post_id   *int64
	likes_count     *int64
	addlikes_count  *int64
	is_top          *bool
	body            *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Reply, error)
	predicates      []predicate.Reply
}

var _ ent.Mutation = (*ReplyMutation)(nil)

// replyOption allows management of the mutation configuration using functional options.
type replyOption func(*ReplyMutation)

// newReplyMutation creates new mutation for the Reply entity.
func newReplyMutation(c config, op Op, opts ...replyOption) *ReplyMutation {
	m := &ReplyMutation{
		config:        c,
		op:            op,
		typ:           TypeReply,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReplyID sets the ID field of the mutation.
func withReplyID(id int64) replyOption {
	return func(m *ReplyMutation) {
		var (
			err   error
			once  sync.Once
			value *Reply
		)
		m.oldValue = func(ctx context.Context) (*Reply, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Reply.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReply sets the old Reply of the mutation.
func withReply(node *Reply) replyOption {
	return func(m *ReplyMutation) {
		m.oldValue = func(context.Context) (*Reply, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReplyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReplyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Reply entities.
func (m *ReplyMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReplyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReplyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Reply.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ReplyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReplyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Reply entity.
// If the Reply object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReplyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReplyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReplyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReplyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Reply entity.
// If the Reply object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReplyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReplyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ReplyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ReplyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Reply entity.
// If the Reply object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReplyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ReplyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[reply.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ReplyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[reply.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ReplyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, reply.FieldDeletedAt)
}

// SetFromRoleID sets the "from_role_id" field.
func (m *ReplyMutation) SetFromRoleID(i int64) {
	m.from_role_id = &i
	m.addfrom_role_id = nil
}

// FromRoleID returns the value of the "from_role_id" field in the mutation.
func (m *ReplyMutation) FromRoleID() (r int64, exists bool) {
	v := m.from_role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromRoleID returns the old "from_role_id" field's value of the Reply entity.
// If the Reply object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReplyMutation) OldFromRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromRoleID: %w", err)
	}
	return oldValue.FromRoleID, nil
}

// AddFromRoleID adds i to the "from_role_id" field.
func (m *ReplyMutation) AddFromRoleID(i int64) {
	if m.addfrom_role_id != nil {
		*m.addfrom_role_id += i
	} else {
		m.addfrom_role_id = &i
	}
}

// AddedFromRoleID returns the value that was added to the "from_role_id" field in this mutation.
func (m *ReplyMutation) AddedFromRoleID() (r int64, exists bool) {
	v := m.addfrom_role_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFromRoleID resets all changes to the "from_role_id" field.
func (m *ReplyMutation) ResetFromRoleID() {
	m.from_role_id = nil
	m.addfrom_role_id = nil
}

// SetToPostID sets the "to_post_id" field.
func (m *ReplyMutation) SetToPostID(i int64) {
	m.to_post_id = &i
	m.addto_post_id = nil
}

// ToPostID returns the value of the "to_post_id" field in the mutation.
func (m *ReplyMutation) ToPostID() (r int64, exists bool) {
	v := m.to_post_id
	if v == nil {
		return
	}
	return *v, true
}

// OldToPostID returns the old "to_post_id" field's value of the Reply entity.
// If the Reply object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReplyMutation) OldToPostID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToPostID: %w", err)
	}
	return oldValue.ToPostID, nil
}

// AddToPostID adds i to the "to_post_id" field.
func (m *ReplyMutation) AddToPostID(i int64) {
	if m.addto_post_id != nil {
		*m.addto_post_id += i
	} else {
		m.addto_post_id = &i
	}
}

// AddedToPostID returns the value that was added to the "to_post_id" field in this mutation.
func (m *ReplyMutation) AddedToPostID() (r int64, exists bool) {
	v := m.addto_post_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetToPostID resets all changes to the "to_post_id" field.
func (m *ReplyMutation) ResetToPostID() {
	m.to_post_id = nil
	m.addto_post_id = nil
}

// SetLikesCount sets the "likes_count" field.
func (m *ReplyMutation) SetLikesCount(i int64) {
	m.likes_count = &i
	m.addlikes_count = nil
}

// LikesCount returns the value of the "likes_count" field in the mutation.
func (m *ReplyMutation) LikesCount() (r int64, exists bool) {
	v := m.likes_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikesCount returns the old "likes_count" field's value of the Reply entity.
// If the Reply object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReplyMutation) OldLikesCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikesCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikesCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikesCount: %w", err)
	}
	return oldValue.LikesCount, nil
}

// AddLikesCount adds i to the "likes_count" field.
func (m *ReplyMutation) AddLikesCount(i int64) {
	if m.addlikes_count != nil {
		*m.addlikes_count += i
	} else {
		m.addlikes_count = &i
	}
}

// AddedLikesCount returns the value that was added to the "likes_count" field in this mutation.
func (m *ReplyMutation) AddedLikesCount() (r int64, exists bool) {
	v := m.addlikes_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikesCount resets all changes to the "likes_count" field.
func (m *ReplyMutation) ResetLikesCount() {
	m.likes_count = nil
	m.addlikes_count = nil
}

// SetIsTop sets the "is_top" field.
func (m *ReplyMutation) SetIsTop(b bool) {
	m.is_top = &b
}

// IsTop returns the value of the "is_top" field in the mutation.
func (m *ReplyMutation) IsTop() (r bool, exists bool) {
	v := m.is_top
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTop returns the old "is_top" field's value of the Reply entity.
// If the Reply object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReplyMutation) OldIsTop(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTop is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTop requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTop: %w", err)
	}
	return oldValue.IsTop, nil
}

// ResetIsTop resets all changes to the "is_top" field.
func (m *ReplyMutation) ResetIsTop() {
	m.is_top = nil
}

// SetBody sets the "body" field.
func (m *ReplyMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *ReplyMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Reply entity.
// If the Reply object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReplyMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *ReplyMutation) ResetBody() {
	m.body = nil
}

// Where appends a list predicates to the ReplyMutation builder.
func (m *ReplyMutation) Where(ps ...predicate.Reply) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReplyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReplyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Reply, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReplyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReplyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Reply).
func (m *ReplyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReplyMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, reply.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, reply.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, reply.FieldDeletedAt)
	}
	if m.from_role_id != nil {
		fields = append(fields, reply.FieldFromRoleID)
	}
	if m.to_post_id != nil {
		fields = append(fields, reply.FieldToPostID)
	}
	if m.likes_count != nil {
		fields = append(fields, reply.FieldLikesCount)
	}
	if m.is_top != nil {
		fields = append(fields, reply.FieldIsTop)
	}
	if m.body != nil {
		fields = append(fields, reply.FieldBody)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReplyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reply.FieldCreatedAt:
		return m.CreatedAt()
	case reply.FieldUpdatedAt:
		return m.UpdatedAt()
	case reply.FieldDeletedAt:
		return m.DeletedAt()
	case reply.FieldFromRoleID:
		return m.FromRoleID()
	case reply.FieldToPostID:
		return m.ToPostID()
	case reply.FieldLikesCount:
		return m.LikesCount()
	case reply.FieldIsTop:
		return m.IsTop()
	case reply.FieldBody:
		return m.Body()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReplyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reply.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case reply.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case reply.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case reply.FieldFromRoleID:
		return m.OldFromRoleID(ctx)
	case reply.FieldToPostID:
		return m.OldToPostID(ctx)
	case reply.FieldLikesCount:
		return m.OldLikesCount(ctx)
	case reply.FieldIsTop:
		return m.OldIsTop(ctx)
	case reply.FieldBody:
		return m.OldBody(ctx)
	}
	return nil, fmt.Errorf("unknown Reply field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReplyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reply.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case reply.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case reply.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case reply.FieldFromRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromRoleID(v)
		return nil
	case reply.FieldToPostID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToPostID(v)
		return nil
	case reply.FieldLikesCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikesCount(v)
		return nil
	case reply.FieldIsTop:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTop(v)
		return nil
	case reply.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	}
	return fmt.Errorf("unknown Reply field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReplyMutation) AddedFields() []string {
	var fields []string
	if m.addfrom_role_id != nil {
		fields = append(fields, reply.FieldFromRoleID)
	}
	if m.addto_post_id != nil {
		fields = append(fields, reply.FieldToPostID)
	}
	if m.addlikes_count != nil {
		fields = append(fields, reply.FieldLikesCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReplyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reply.FieldFromRoleID:
		return m.AddedFromRoleID()
	case reply.FieldToPostID:
		return m.AddedToPostID()
	case reply.FieldLikesCount:
		return m.AddedLikesCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReplyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reply.FieldFromRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromRoleID(v)
		return nil
	case reply.FieldToPostID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToPostID(v)
		return nil
	case reply.FieldLikesCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikesCount(v)
		return nil
	}
	return fmt.Errorf("unknown Reply numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReplyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reply.FieldDeletedAt) {
		fields = append(fields, reply.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReplyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReplyMutation) ClearField(name string) error {
	switch name {
	case reply.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Reply nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReplyMutation) ResetField(name string) error {
	switch name {
	case reply.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case reply.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case reply.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case reply.FieldFromRoleID:
		m.ResetFromRoleID()
		return nil
	case reply.FieldToPostID:
		m.ResetToPostID()
		return nil
	case reply.FieldLikesCount:
		m.ResetLikesCount()
		return nil
	case reply.FieldIsTop:
		m.ResetIsTop()
		return nil
	case reply.FieldBody:
		m.ResetBody()
		return nil
	}
	return fmt.Errorf("unknown Reply field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReplyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReplyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReplyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReplyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReplyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReplyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReplyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Reply unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReplyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Reply edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	email               *string
	hashed_pwd          *string
	password_changed_at *time.Time
	role_name           *string
	_type               *role.Type
	statement           *string
	posts_count         *int64
	addposts_count      *int64
	comments_count      *int64
	addcomments_count   *int64
	replies_count       *int64
	addreplies_count    *int64
	likes_count         *int64
	addlikes_count      *int64
	helps_count         *int64
	addhelps_count      *int64
	fans_count          *int64
	addfans_count       *int64
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*Role, error)
	predicates          []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int64) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[role.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, role.FieldDeletedAt)
}

// SetEmail sets the "email" field.
func (m *RoleMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *RoleMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *RoleMutation) ResetEmail() {
	m.email = nil
}

// SetHashedPwd sets the "hashed_pwd" field.
func (m *RoleMutation) SetHashedPwd(s string) {
	m.hashed_pwd = &s
}

// HashedPwd returns the value of the "hashed_pwd" field in the mutation.
func (m *RoleMutation) HashedPwd() (r string, exists bool) {
	v := m.hashed_pwd
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedPwd returns the old "hashed_pwd" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldHashedPwd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedPwd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedPwd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedPwd: %w", err)
	}
	return oldValue.HashedPwd, nil
}

// ResetHashedPwd resets all changes to the "hashed_pwd" field.
func (m *RoleMutation) ResetHashedPwd() {
	m.hashed_pwd = nil
}

// SetPasswordChangedAt sets the "password_changed_at" field.
func (m *RoleMutation) SetPasswordChangedAt(t time.Time) {
	m.password_changed_at = &t
}

// PasswordChangedAt returns the value of the "password_changed_at" field in the mutation.
func (m *RoleMutation) PasswordChangedAt() (r time.Time, exists bool) {
	v := m.password_changed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordChangedAt returns the old "password_changed_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldPasswordChangedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordChangedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordChangedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordChangedAt: %w", err)
	}
	return oldValue.PasswordChangedAt, nil
}

// ResetPasswordChangedAt resets all changes to the "password_changed_at" field.
func (m *RoleMutation) ResetPasswordChangedAt() {
	m.password_changed_at = nil
}

// SetRoleName sets the "role_name" field.
func (m *RoleMutation) SetRoleName(s string) {
	m.role_name = &s
}

// RoleName returns the value of the "role_name" field in the mutation.
func (m *RoleMutation) RoleName() (r string, exists bool) {
	v := m.role_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleName returns the old "role_name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRoleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleName: %w", err)
	}
	return oldValue.RoleName, nil
}

// ResetRoleName resets all changes to the "role_name" field.
func (m *RoleMutation) ResetRoleName() {
	m.role_name = nil
}

// SetType sets the "type" field.
func (m *RoleMutation) SetType(r role.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *RoleMutation) GetType() (r role.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldType(ctx context.Context) (v role.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RoleMutation) ResetType() {
	m._type = nil
}

// SetStatement sets the "statement" field.
func (m *RoleMutation) SetStatement(s string) {
	m.statement = &s
}

// Statement returns the value of the "statement" field in the mutation.
func (m *RoleMutation) Statement() (r string, exists bool) {
	v := m.statement
	if v == nil {
		return
	}
	return *v, true
}

// OldStatement returns the old "statement" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldStatement(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatement: %w", err)
	}
	return oldValue.Statement, nil
}

// ClearStatement clears the value of the "statement" field.
func (m *RoleMutation) ClearStatement() {
	m.statement = nil
	m.clearedFields[role.FieldStatement] = struct{}{}
}

// StatementCleared returns if the "statement" field was cleared in this mutation.
func (m *RoleMutation) StatementCleared() bool {
	_, ok := m.clearedFields[role.FieldStatement]
	return ok
}

// ResetStatement resets all changes to the "statement" field.
func (m *RoleMutation) ResetStatement() {
	m.statement = nil
	delete(m.clearedFields, role.FieldStatement)
}

// SetPostsCount sets the "posts_count" field.
func (m *RoleMutation) SetPostsCount(i int64) {
	m.posts_count = &i
	m.addposts_count = nil
}

// PostsCount returns the value of the "posts_count" field in the mutation.
func (m *RoleMutation) PostsCount() (r int64, exists bool) {
	v := m.posts_count
	if v == nil {
		return
	}
	return *v, true
}

// OldPostsCount returns the old "posts_count" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldPostsCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostsCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostsCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostsCount: %w", err)
	}
	return oldValue.PostsCount, nil
}

// AddPostsCount adds i to the "posts_count" field.
func (m *RoleMutation) AddPostsCount(i int64) {
	if m.addposts_count != nil {
		*m.addposts_count += i
	} else {
		m.addposts_count = &i
	}
}

// AddedPostsCount returns the value that was added to the "posts_count" field in this mutation.
func (m *RoleMutation) AddedPostsCount() (r int64, exists bool) {
	v := m.addposts_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetPostsCount resets all changes to the "posts_count" field.
func (m *RoleMutation) ResetPostsCount() {
	m.posts_count = nil
	m.addposts_count = nil
}

// SetCommentsCount sets the "comments_count" field.
func (m *RoleMutation) SetCommentsCount(i int64) {
	m.comments_count = &i
	m.addcomments_count = nil
}

// CommentsCount returns the value of the "comments_count" field in the mutation.
func (m *RoleMutation) CommentsCount() (r int64, exists bool) {
	v := m.comments_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentsCount returns the old "comments_count" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCommentsCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentsCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentsCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentsCount: %w", err)
	}
	return oldValue.CommentsCount, nil
}

// AddCommentsCount adds i to the "comments_count" field.
func (m *RoleMutation) AddCommentsCount(i int64) {
	if m.addcomments_count != nil {
		*m.addcomments_count += i
	} else {
		m.addcomments_count = &i
	}
}

// AddedCommentsCount returns the value that was added to the "comments_count" field in this mutation.
func (m *RoleMutation) AddedCommentsCount() (r int64, exists bool) {
	v := m.addcomments_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentsCount resets all changes to the "comments_count" field.
func (m *RoleMutation) ResetCommentsCount() {
	m.comments_count = nil
	m.addcomments_count = nil
}

// SetRepliesCount sets the "replies_count" field.
func (m *RoleMutation) SetRepliesCount(i int64) {
	m.replies_count = &i
	m.addreplies_count = nil
}

// RepliesCount returns the value of the "replies_count" field in the mutation.
func (m *RoleMutation) RepliesCount() (r int64, exists bool) {
	v := m.replies_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRepliesCount returns the old "replies_count" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRepliesCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepliesCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepliesCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepliesCount: %w", err)
	}
	return oldValue.RepliesCount, nil
}

// AddRepliesCount adds i to the "replies_count" field.
func (m *RoleMutation) AddRepliesCount(i int64) {
	if m.addreplies_count != nil {
		*m.addreplies_count += i
	} else {
		m.addreplies_count = &i
	}
}

// AddedRepliesCount returns the value that was added to the "replies_count" field in this mutation.
func (m *RoleMutation) AddedRepliesCount() (r int64, exists bool) {
	v := m.addreplies_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRepliesCount resets all changes to the "replies_count" field.
func (m *RoleMutation) ResetRepliesCount() {
	m.replies_count = nil
	m.addreplies_count = nil
}

// SetLikesCount sets the "likes_count" field.
func (m *RoleMutation) SetLikesCount(i int64) {
	m.likes_count = &i
	m.addlikes_count = nil
}

// LikesCount returns the value of the "likes_count" field in the mutation.
func (m *RoleMutation) LikesCount() (r int64, exists bool) {
	v := m.likes_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikesCount returns the old "likes_count" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldLikesCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikesCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikesCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikesCount: %w", err)
	}
	return oldValue.LikesCount, nil
}

// AddLikesCount adds i to the "likes_count" field.
func (m *RoleMutation) AddLikesCount(i int64) {
	if m.addlikes_count != nil {
		*m.addlikes_count += i
	} else {
		m.addlikes_count = &i
	}
}

// AddedLikesCount returns the value that was added to the "likes_count" field in this mutation.
func (m *RoleMutation) AddedLikesCount() (r int64, exists bool) {
	v := m.addlikes_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikesCount resets all changes to the "likes_count" field.
func (m *RoleMutation) ResetLikesCount() {
	m.likes_count = nil
	m.addlikes_count = nil
}

// SetHelpsCount sets the "helps_count" field.
func (m *RoleMutation) SetHelpsCount(i int64) {
	m.helps_count = &i
	m.addhelps_count = nil
}

// HelpsCount returns the value of the "helps_count" field in the mutation.
func (m *RoleMutation) HelpsCount() (r int64, exists bool) {
	v := m.helps_count
	if v == nil {
		return
	}
	return *v, true
}

// OldHelpsCount returns the old "helps_count" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldHelpsCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHelpsCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHelpsCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHelpsCount: %w", err)
	}
	return oldValue.HelpsCount, nil
}

// AddHelpsCount adds i to the "helps_count" field.
func (m *RoleMutation) AddHelpsCount(i int64) {
	if m.addhelps_count != nil {
		*m.addhelps_count += i
	} else {
		m.addhelps_count = &i
	}
}

// AddedHelpsCount returns the value that was added to the "helps_count" field in this mutation.
func (m *RoleMutation) AddedHelpsCount() (r int64, exists bool) {
	v := m.addhelps_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetHelpsCount resets all changes to the "helps_count" field.
func (m *RoleMutation) ResetHelpsCount() {
	m.helps_count = nil
	m.addhelps_count = nil
}

// SetFansCount sets the "fans_count" field.
func (m *RoleMutation) SetFansCount(i int64) {
	m.fans_count = &i
	m.addfans_count = nil
}

// FansCount returns the value of the "fans_count" field in the mutation.
func (m *RoleMutation) FansCount() (r int64, exists bool) {
	v := m.fans_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFansCount returns the old "fans_count" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldFansCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFansCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFansCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFansCount: %w", err)
	}
	return oldValue.FansCount, nil
}

// AddFansCount adds i to the "fans_count" field.
func (m *RoleMutation) AddFansCount(i int64) {
	if m.addfans_count != nil {
		*m.addfans_count += i
	} else {
		m.addfans_count = &i
	}
}

// AddedFansCount returns the value that was added to the "fans_count" field in this mutation.
func (m *RoleMutation) AddedFansCount() (r int64, exists bool) {
	v := m.addfans_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFansCount resets all changes to the "fans_count" field.
func (m *RoleMutation) ResetFansCount() {
	m.fans_count = nil
	m.addfans_count = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.email != nil {
		fields = append(fields, role.FieldEmail)
	}
	if m.hashed_pwd != nil {
		fields = append(fields, role.FieldHashedPwd)
	}
	if m.password_changed_at != nil {
		fields = append(fields, role.FieldPasswordChangedAt)
	}
	if m.role_name != nil {
		fields = append(fields, role.FieldRoleName)
	}
	if m._type != nil {
		fields = append(fields, role.FieldType)
	}
	if m.statement != nil {
		fields = append(fields, role.FieldStatement)
	}
	if m.posts_count != nil {
		fields = append(fields, role.FieldPostsCount)
	}
	if m.comments_count != nil {
		fields = append(fields, role.FieldCommentsCount)
	}
	if m.replies_count != nil {
		fields = append(fields, role.FieldRepliesCount)
	}
	if m.likes_count != nil {
		fields = append(fields, role.FieldLikesCount)
	}
	if m.helps_count != nil {
		fields = append(fields, role.FieldHelpsCount)
	}
	if m.fans_count != nil {
		fields = append(fields, role.FieldFansCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDeletedAt:
		return m.DeletedAt()
	case role.FieldEmail:
		return m.Email()
	case role.FieldHashedPwd:
		return m.HashedPwd()
	case role.FieldPasswordChangedAt:
		return m.PasswordChangedAt()
	case role.FieldRoleName:
		return m.RoleName()
	case role.FieldType:
		return m.GetType()
	case role.FieldStatement:
		return m.Statement()
	case role.FieldPostsCount:
		return m.PostsCount()
	case role.FieldCommentsCount:
		return m.CommentsCount()
	case role.FieldRepliesCount:
		return m.RepliesCount()
	case role.FieldLikesCount:
		return m.LikesCount()
	case role.FieldHelpsCount:
		return m.HelpsCount()
	case role.FieldFansCount:
		return m.FansCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case role.FieldEmail:
		return m.OldEmail(ctx)
	case role.FieldHashedPwd:
		return m.OldHashedPwd(ctx)
	case role.FieldPasswordChangedAt:
		return m.OldPasswordChangedAt(ctx)
	case role.FieldRoleName:
		return m.OldRoleName(ctx)
	case role.FieldType:
		return m.OldType(ctx)
	case role.FieldStatement:
		return m.OldStatement(ctx)
	case role.FieldPostsCount:
		return m.OldPostsCount(ctx)
	case role.FieldCommentsCount:
		return m.OldCommentsCount(ctx)
	case role.FieldRepliesCount:
		return m.OldRepliesCount(ctx)
	case role.FieldLikesCount:
		return m.OldLikesCount(ctx)
	case role.FieldHelpsCount:
		return m.OldHelpsCount(ctx)
	case role.FieldFansCount:
		return m.OldFansCount(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case role.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case role.FieldHashedPwd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedPwd(v)
		return nil
	case role.FieldPasswordChangedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordChangedAt(v)
		return nil
	case role.FieldRoleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleName(v)
		return nil
	case role.FieldType:
		v, ok := value.(role.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case role.FieldStatement:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatement(v)
		return nil
	case role.FieldPostsCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostsCount(v)
		return nil
	case role.FieldCommentsCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentsCount(v)
		return nil
	case role.FieldRepliesCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepliesCount(v)
		return nil
	case role.FieldLikesCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikesCount(v)
		return nil
	case role.FieldHelpsCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHelpsCount(v)
		return nil
	case role.FieldFansCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFansCount(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.addposts_count != nil {
		fields = append(fields, role.FieldPostsCount)
	}
	if m.addcomments_count != nil {
		fields = append(fields, role.FieldCommentsCount)
	}
	if m.addreplies_count != nil {
		fields = append(fields, role.FieldRepliesCount)
	}
	if m.addlikes_count != nil {
		fields = append(fields, role.FieldLikesCount)
	}
	if m.addhelps_count != nil {
		fields = append(fields, role.FieldHelpsCount)
	}
	if m.addfans_count != nil {
		fields = append(fields, role.FieldFansCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldPostsCount:
		return m.AddedPostsCount()
	case role.FieldCommentsCount:
		return m.AddedCommentsCount()
	case role.FieldRepliesCount:
		return m.AddedRepliesCount()
	case role.FieldLikesCount:
		return m.AddedLikesCount()
	case role.FieldHelpsCount:
		return m.AddedHelpsCount()
	case role.FieldFansCount:
		return m.AddedFansCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldPostsCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostsCount(v)
		return nil
	case role.FieldCommentsCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentsCount(v)
		return nil
	case role.FieldRepliesCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRepliesCount(v)
		return nil
	case role.FieldLikesCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikesCount(v)
		return nil
	case role.FieldHelpsCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHelpsCount(v)
		return nil
	case role.FieldFansCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFansCount(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDeletedAt) {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.FieldCleared(role.FieldStatement) {
		fields = append(fields, role.FieldStatement)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case role.FieldStatement:
		m.ClearStatement()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case role.FieldEmail:
		m.ResetEmail()
		return nil
	case role.FieldHashedPwd:
		m.ResetHashedPwd()
		return nil
	case role.FieldPasswordChangedAt:
		m.ResetPasswordChangedAt()
		return nil
	case role.FieldRoleName:
		m.ResetRoleName()
		return nil
	case role.FieldType:
		m.ResetType()
		return nil
	case role.FieldStatement:
		m.ResetStatement()
		return nil
	case role.FieldPostsCount:
		m.ResetPostsCount()
		return nil
	case role.FieldCommentsCount:
		m.ResetCommentsCount()
		return nil
	case role.FieldRepliesCount:
		m.ResetRepliesCount()
		return nil
	case role.FieldLikesCount:
		m.ResetLikesCount()
		return nil
	case role.FieldHelpsCount:
		m.ResetHelpsCount()
		return nil
	case role.FieldFansCount:
		m.ResetFansCount()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Role edge %s", name)
}

// SectionMutation represents an operation that mutates the Section nodes in the graph.
type SectionMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	section_name  *string
	statement     *string
	manager_id    *int64
	addmanager_id *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Section, error)
	predicates    []predicate.Section
}

var _ ent.Mutation = (*SectionMutation)(nil)

// sectionOption allows management of the mutation configuration using functional options.
type sectionOption func(*SectionMutation)

// newSectionMutation creates new mutation for the Section entity.
func newSectionMutation(c config, op Op, opts ...sectionOption) *SectionMutation {
	m := &SectionMutation{
		config:        c,
		op:            op,
		typ:           TypeSection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSectionID sets the ID field of the mutation.
func withSectionID(id int64) sectionOption {
	return func(m *SectionMutation) {
		var (
			err   error
			once  sync.Once
			value *Section
		)
		m.oldValue = func(ctx context.Context) (*Section, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Section.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSection sets the old Section of the mutation.
func withSection(node *Section) sectionOption {
	return func(m *SectionMutation) {
		m.oldValue = func(context.Context) (*Section, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Section entities.
func (m *SectionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SectionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SectionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Section.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Section entity.
// If the Section object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Section entity.
// If the Section object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SectionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SectionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Section entity.
// If the Section object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SectionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SectionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[section.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SectionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[section.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SectionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, section.FieldDeletedAt)
}

// SetSectionName sets the "section_name" field.
func (m *SectionMutation) SetSectionName(s string) {
	m.section_name = &s
}

// SectionName returns the value of the "section_name" field in the mutation.
func (m *SectionMutation) SectionName() (r string, exists bool) {
	v := m.section_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSectionName returns the old "section_name" field's value of the Section entity.
// If the Section object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SectionMutation) OldSectionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSectionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSectionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSectionName: %w", err)
	}
	return oldValue.SectionName, nil
}

// ResetSectionName resets all changes to the "section_name" field.
func (m *SectionMutation) ResetSectionName() {
	m.section_name = nil
}

// SetStatement sets the "statement" field.
func (m *SectionMutation) SetStatement(s string) {
	m.statement = &s
}

// Statement returns the value of the "statement" field in the mutation.
func (m *SectionMutation) Statement() (r string, exists bool) {
	v := m.statement
	if v == nil {
		return
	}
	return *v, true
}

// OldStatement returns the old "statement" field's value of the Section entity.
// If the Section object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SectionMutation) OldStatement(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatement: %w", err)
	}
	return oldValue.Statement, nil
}

// ClearStatement clears the value of the "statement" field.
func (m *SectionMutation) ClearStatement() {
	m.statement = nil
	m.clearedFields[section.FieldStatement] = struct{}{}
}

// StatementCleared returns if the "statement" field was cleared in this mutation.
func (m *SectionMutation) StatementCleared() bool {
	_, ok := m.clearedFields[section.FieldStatement]
	return ok
}

// ResetStatement resets all changes to the "statement" field.
func (m *SectionMutation) ResetStatement() {
	m.statement = nil
	delete(m.clearedFields, section.FieldStatement)
}

// SetManagerID sets the "manager_id" field.
func (m *SectionMutation) SetManagerID(i int64) {
	m.manager_id = &i
	m.addmanager_id = nil
}

// ManagerID returns the value of the "manager_id" field in the mutation.
func (m *SectionMutation) ManagerID() (r int64, exists bool) {
	v := m.manager_id
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerID returns the old "manager_id" field's value of the Section entity.
// If the Section object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SectionMutation) OldManagerID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerID: %w", err)
	}
	return oldValue.ManagerID, nil
}

// AddManagerID adds i to the "manager_id" field.
func (m *SectionMutation) AddManagerID(i int64) {
	if m.addmanager_id != nil {
		*m.addmanager_id += i
	} else {
		m.addmanager_id = &i
	}
}

// AddedManagerID returns the value that was added to the "manager_id" field in this mutation.
func (m *SectionMutation) AddedManagerID() (r int64, exists bool) {
	v := m.addmanager_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetManagerID resets all changes to the "manager_id" field.
func (m *SectionMutation) ResetManagerID() {
	m.manager_id = nil
	m.addmanager_id = nil
}

// Where appends a list predicates to the SectionMutation builder.
func (m *SectionMutation) Where(ps ...predicate.Section) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Section, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Section).
func (m *SectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SectionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, section.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, section.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, section.FieldDeletedAt)
	}
	if m.section_name != nil {
		fields = append(fields, section.FieldSectionName)
	}
	if m.statement != nil {
		fields = append(fields, section.FieldStatement)
	}
	if m.manager_id != nil {
		fields = append(fields, section.FieldManagerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case section.FieldCreatedAt:
		return m.CreatedAt()
	case section.FieldUpdatedAt:
		return m.UpdatedAt()
	case section.FieldDeletedAt:
		return m.DeletedAt()
	case section.FieldSectionName:
		return m.SectionName()
	case section.FieldStatement:
		return m.Statement()
	case section.FieldManagerID:
		return m.ManagerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case section.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case section.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case section.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case section.FieldSectionName:
		return m.OldSectionName(ctx)
	case section.FieldStatement:
		return m.OldStatement(ctx)
	case section.FieldManagerID:
		return m.OldManagerID(ctx)
	}
	return nil, fmt.Errorf("unknown Section field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case section.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case section.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case section.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case section.FieldSectionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSectionName(v)
		return nil
	case section.FieldStatement:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatement(v)
		return nil
	case section.FieldManagerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerID(v)
		return nil
	}
	return fmt.Errorf("unknown Section field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SectionMutation) AddedFields() []string {
	var fields []string
	if m.addmanager_id != nil {
		fields = append(fields, section.FieldManagerID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SectionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case section.FieldManagerID:
		return m.AddedManagerID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case section.FieldManagerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddManagerID(v)
		return nil
	}
	return fmt.Errorf("unknown Section numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(section.FieldDeletedAt) {
		fields = append(fields, section.FieldDeletedAt)
	}
	if m.FieldCleared(section.FieldStatement) {
		fields = append(fields, section.FieldStatement)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SectionMutation) ClearField(name string) error {
	switch name {
	case section.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case section.FieldStatement:
		m.ClearStatement()
		return nil
	}
	return fmt.Errorf("unknown Section nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SectionMutation) ResetField(name string) error {
	switch name {
	case section.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case section.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case section.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case section.FieldSectionName:
		m.ResetSectionName()
		return nil
	case section.FieldStatement:
		m.ResetStatement()
		return nil
	case section.FieldManagerID:
		m.ResetManagerID()
		return nil
	}
	return fmt.Errorf("unknown Section field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SectionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SectionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SectionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SectionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Section unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SectionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Section edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	role_id       *int64
	addrole_id    *int64
	created_at    *time.Time
	expires_at    *time.Time
	user_agent    *string
	client_ip     *string
	is_blocked    *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Session, error)
	predicates    []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id uuid.UUID) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoleID sets the "role_id" field.
func (m *SessionMutation) SetRoleID(i int64) {
	m.role_id = &i
	m.addrole_id = nil
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *SessionMutation) RoleID() (r int64, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds i to the "role_id" field.
func (m *SessionMutation) AddRoleID(i int64) {
	if m.addrole_id != nil {
		*m.addrole_id += i
	} else {
		m.addrole_id = &i
	}
}

// AddedRoleID returns the value that was added to the "role_id" field in this mutation.
func (m *SessionMutation) AddedRoleID() (r int64, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *SessionMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUserAgent sets the "user_agent" field.
func (m *SessionMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *SessionMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *SessionMutation) ResetUserAgent() {
	m.user_agent = nil
}

// SetClientIP sets the "client_ip" field.
func (m *SessionMutation) SetClientIP(s string) {
	m.client_ip = &s
}

// ClientIP returns the value of the "client_ip" field in the mutation.
func (m *SessionMutation) ClientIP() (r string, exists bool) {
	v := m.client_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldClientIP returns the old "client_ip" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldClientIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientIP: %w", err)
	}
	return oldValue.ClientIP, nil
}

// ResetClientIP resets all changes to the "client_ip" field.
func (m *SessionMutation) ResetClientIP() {
	m.client_ip = nil
}

// SetIsBlocked sets the "is_blocked" field.
func (m *SessionMutation) SetIsBlocked(b bool) {
	m.is_blocked = &b
}

// IsBlocked returns the value of the "is_blocked" field in the mutation.
func (m *SessionMutation) IsBlocked() (r bool, exists bool) {
	v := m.is_blocked
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBlocked returns the old "is_blocked" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIsBlocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBlocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBlocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBlocked: %w", err)
	}
	return oldValue.IsBlocked, nil
}

// ResetIsBlocked resets all changes to the "is_blocked" field.
func (m *SessionMutation) ResetIsBlocked() {
	m.is_blocked = nil
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.role_id != nil {
		fields = append(fields, session.FieldRoleID)
	}
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	if m.user_agent != nil {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.client_ip != nil {
		fields = append(fields, session.FieldClientIP)
	}
	if m.is_blocked != nil {
		fields = append(fields, session.FieldIsBlocked)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldRoleID:
		return m.RoleID()
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	case session.FieldUserAgent:
		return m.UserAgent()
	case session.FieldClientIP:
		return m.ClientIP()
	case session.FieldIsBlocked:
		return m.IsBlocked()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldRoleID:
		return m.OldRoleID(ctx)
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case session.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case session.FieldClientIP:
		return m.OldClientIP(ctx)
	case session.FieldIsBlocked:
		return m.OldIsBlocked(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case session.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case session.FieldClientIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientIP(v)
		return nil
	case session.FieldIsBlocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBlocked(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	var fields []string
	if m.addrole_id != nil {
		fields = append(fields, session.FieldRoleID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case session.FieldRoleID:
		return m.AddedRoleID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case session.FieldRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldRoleID:
		m.ResetRoleID()
		return nil
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case session.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case session.FieldClientIP:
		m.ResetClientIP()
		return nil
	case session.FieldIsBlocked:
		m.ResetIsBlocked()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Session edge %s", name)
}

// StarMutation represents an operation that mutates the Star nodes in the graph.
type StarMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	from_role_id    *int64
	addfrom_role_id *int64
	secne_type      *star.SecneType
	sence_id        *int64
	addsence_id     *int64
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Star, error)
	predicates      []predicate.Star
}

var _ ent.Mutation = (*StarMutation)(nil)

// starOption allows management of the mutation configuration using functional options.
type starOption func(*StarMutation)

// newStarMutation creates new mutation for the Star entity.
func newStarMutation(c config, op Op, opts ...starOption) *StarMutation {
	m := &StarMutation{
		config:        c,
		op:            op,
		typ:           TypeStar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStarID sets the ID field of the mutation.
func withStarID(id int64) starOption {
	return func(m *StarMutation) {
		var (
			err   error
			once  sync.Once
			value *Star
		)
		m.oldValue = func(ctx context.Context) (*Star, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Star.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStar sets the old Star of the mutation.
func withStar(node *Star) starOption {
	return func(m *StarMutation) {
		m.oldValue = func(context.Context) (*Star, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Star entities.
func (m *StarMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StarMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StarMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Star.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StarMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StarMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Star entity.
// If the Star object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StarMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StarMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StarMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StarMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Star entity.
// If the Star object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StarMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StarMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StarMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StarMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Star entity.
// If the Star object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StarMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StarMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[star.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StarMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[star.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StarMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, star.FieldDeletedAt)
}

// SetFromRoleID sets the "from_role_id" field.
func (m *StarMutation) SetFromRoleID(i int64) {
	m.from_role_id = &i
	m.addfrom_role_id = nil
}

// FromRoleID returns the value of the "from_role_id" field in the mutation.
func (m *StarMutation) FromRoleID() (r int64, exists bool) {
	v := m.from_role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromRoleID returns the old "from_role_id" field's value of the Star entity.
// If the Star object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StarMutation) OldFromRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromRoleID: %w", err)
	}
	return oldValue.FromRoleID, nil
}

// AddFromRoleID adds i to the "from_role_id" field.
func (m *StarMutation) AddFromRoleID(i int64) {
	if m.addfrom_role_id != nil {
		*m.addfrom_role_id += i
	} else {
		m.addfrom_role_id = &i
	}
}

// AddedFromRoleID returns the value that was added to the "from_role_id" field in this mutation.
func (m *StarMutation) AddedFromRoleID() (r int64, exists bool) {
	v := m.addfrom_role_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFromRoleID resets all changes to the "from_role_id" field.
func (m *StarMutation) ResetFromRoleID() {
	m.from_role_id = nil
	m.addfrom_role_id = nil
}

// SetSecneType sets the "secne_type" field.
func (m *StarMutation) SetSecneType(st star.SecneType) {
	m.secne_type = &st
}

// SecneType returns the value of the "secne_type" field in the mutation.
func (m *StarMutation) SecneType() (r star.SecneType, exists bool) {
	v := m.secne_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSecneType returns the old "secne_type" field's value of the Star entity.
// If the Star object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StarMutation) OldSecneType(ctx context.Context) (v star.SecneType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecneType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecneType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecneType: %w", err)
	}
	return oldValue.SecneType, nil
}

// ResetSecneType resets all changes to the "secne_type" field.
func (m *StarMutation) ResetSecneType() {
	m.secne_type = nil
}

// SetSenceID sets the "sence_id" field.
func (m *StarMutation) SetSenceID(i int64) {
	m.sence_id = &i
	m.addsence_id = nil
}

// SenceID returns the value of the "sence_id" field in the mutation.
func (m *StarMutation) SenceID() (r int64, exists bool) {
	v := m.sence_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSenceID returns the old "sence_id" field's value of the Star entity.
// If the Star object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StarMutation) OldSenceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenceID: %w", err)
	}
	return oldValue.SenceID, nil
}

// AddSenceID adds i to the "sence_id" field.
func (m *StarMutation) AddSenceID(i int64) {
	if m.addsence_id != nil {
		*m.addsence_id += i
	} else {
		m.addsence_id = &i
	}
}

// AddedSenceID returns the value that was added to the "sence_id" field in this mutation.
func (m *StarMutation) AddedSenceID() (r int64, exists bool) {
	v := m.addsence_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSenceID resets all changes to the "sence_id" field.
func (m *StarMutation) ResetSenceID() {
	m.sence_id = nil
	m.addsence_id = nil
}

// Where appends a list predicates to the StarMutation builder.
func (m *StarMutation) Where(ps ...predicate.Star) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StarMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StarMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Star, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StarMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StarMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Star).
func (m *StarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StarMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, star.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, star.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, star.FieldDeletedAt)
	}
	if m.from_role_id != nil {
		fields = append(fields, star.FieldFromRoleID)
	}
	if m.secne_type != nil {
		fields = append(fields, star.FieldSecneType)
	}
	if m.sence_id != nil {
		fields = append(fields, star.FieldSenceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StarMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case star.FieldCreatedAt:
		return m.CreatedAt()
	case star.FieldUpdatedAt:
		return m.UpdatedAt()
	case star.FieldDeletedAt:
		return m.DeletedAt()
	case star.FieldFromRoleID:
		return m.FromRoleID()
	case star.FieldSecneType:
		return m.SecneType()
	case star.FieldSenceID:
		return m.SenceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case star.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case star.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case star.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case star.FieldFromRoleID:
		return m.OldFromRoleID(ctx)
	case star.FieldSecneType:
		return m.OldSecneType(ctx)
	case star.FieldSenceID:
		return m.OldSenceID(ctx)
	}
	return nil, fmt.Errorf("unknown Star field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StarMutation) SetField(name string, value ent.Value) error {
	switch name {
	case star.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case star.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case star.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case star.FieldFromRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromRoleID(v)
		return nil
	case star.FieldSecneType:
		v, ok := value.(star.SecneType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecneType(v)
		return nil
	case star.FieldSenceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenceID(v)
		return nil
	}
	return fmt.Errorf("unknown Star field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StarMutation) AddedFields() []string {
	var fields []string
	if m.addfrom_role_id != nil {
		fields = append(fields, star.FieldFromRoleID)
	}
	if m.addsence_id != nil {
		fields = append(fields, star.FieldSenceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StarMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case star.FieldFromRoleID:
		return m.AddedFromRoleID()
	case star.FieldSenceID:
		return m.AddedSenceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StarMutation) AddField(name string, value ent.Value) error {
	switch name {
	case star.FieldFromRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromRoleID(v)
		return nil
	case star.FieldSenceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSenceID(v)
		return nil
	}
	return fmt.Errorf("unknown Star numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StarMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(star.FieldDeletedAt) {
		fields = append(fields, star.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StarMutation) ClearField(name string) error {
	switch name {
	case star.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Star nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StarMutation) ResetField(name string) error {
	switch name {
	case star.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case star.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case star.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case star.FieldFromRoleID:
		m.ResetFromRoleID()
		return nil
	case star.FieldSecneType:
		m.ResetSecneType()
		return nil
	case star.FieldSenceID:
		m.ResetSenceID()
		return nil
	}
	return fmt.Errorf("unknown Star field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StarMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StarMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StarMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StarMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StarMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Star unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StarMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Star edge %s", name)
}

// VoteMutation represents an operation that mutates the Vote nodes in the graph.
type VoteMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	from_post_id    *int64
	addfrom_post_id *int64
	register        *bool
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Vote, error)
	predicates      []predicate.Vote
}

var _ ent.Mutation = (*VoteMutation)(nil)

// voteOption allows management of the mutation configuration using functional options.
type voteOption func(*VoteMutation)

// newVoteMutation creates new mutation for the Vote entity.
func newVoteMutation(c config, op Op, opts ...voteOption) *VoteMutation {
	m := &VoteMutation{
		config:        c,
		op:            op,
		typ:           TypeVote,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVoteID sets the ID field of the mutation.
func withVoteID(id int64) voteOption {
	return func(m *VoteMutation) {
		var (
			err   error
			once  sync.Once
			value *Vote
		)
		m.oldValue = func(ctx context.Context) (*Vote, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vote.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVote sets the old Vote of the mutation.
func withVote(node *Vote) voteOption {
	return func(m *VoteMutation) {
		m.oldValue = func(context.Context) (*Vote, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VoteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VoteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Vote entities.
func (m *VoteMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VoteMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VoteMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Vote.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VoteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VoteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VoteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VoteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VoteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VoteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VoteMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VoteMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *VoteMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[vote.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *VoteMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[vote.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VoteMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, vote.FieldDeletedAt)
}

// SetFromPostID sets the "from_post_id" field.
func (m *VoteMutation) SetFromPostID(i int64) {
	m.from_post_id = &i
	m.addfrom_post_id = nil
}

// FromPostID returns the value of the "from_post_id" field in the mutation.
func (m *VoteMutation) FromPostID() (r int64, exists bool) {
	v := m.from_post_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromPostID returns the old "from_post_id" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldFromPostID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromPostID: %w", err)
	}
	return oldValue.FromPostID, nil
}

// AddFromPostID adds i to the "from_post_id" field.
func (m *VoteMutation) AddFromPostID(i int64) {
	if m.addfrom_post_id != nil {
		*m.addfrom_post_id += i
	} else {
		m.addfrom_post_id = &i
	}
}

// AddedFromPostID returns the value that was added to the "from_post_id" field in this mutation.
func (m *VoteMutation) AddedFromPostID() (r int64, exists bool) {
	v := m.addfrom_post_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFromPostID resets all changes to the "from_post_id" field.
func (m *VoteMutation) ResetFromPostID() {
	m.from_post_id = nil
	m.addfrom_post_id = nil
}

// SetRegister sets the "register" field.
func (m *VoteMutation) SetRegister(b bool) {
	m.register = &b
}

// Register returns the value of the "register" field in the mutation.
func (m *VoteMutation) Register() (r bool, exists bool) {
	v := m.register
	if v == nil {
		return
	}
	return *v, true
}

// OldRegister returns the old "register" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldRegister(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegister is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegister requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegister: %w", err)
	}
	return oldValue.Register, nil
}

// ResetRegister resets all changes to the "register" field.
func (m *VoteMutation) ResetRegister() {
	m.register = nil
}

// Where appends a list predicates to the VoteMutation builder.
func (m *VoteMutation) Where(ps ...predicate.Vote) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VoteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VoteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Vote, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VoteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VoteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Vote).
func (m *VoteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VoteMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, vote.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vote.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, vote.FieldDeletedAt)
	}
	if m.from_post_id != nil {
		fields = append(fields, vote.FieldFromPostID)
	}
	if m.register != nil {
		fields = append(fields, vote.FieldRegister)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VoteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vote.FieldCreatedAt:
		return m.CreatedAt()
	case vote.FieldUpdatedAt:
		return m.UpdatedAt()
	case vote.FieldDeletedAt:
		return m.DeletedAt()
	case vote.FieldFromPostID:
		return m.FromPostID()
	case vote.FieldRegister:
		return m.Register()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vote.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vote.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vote.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case vote.FieldFromPostID:
		return m.OldFromPostID(ctx)
	case vote.FieldRegister:
		return m.OldRegister(ctx)
	}
	return nil, fmt.Errorf("unknown Vote field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vote.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vote.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vote.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case vote.FieldFromPostID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromPostID(v)
		return nil
	case vote.FieldRegister:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegister(v)
		return nil
	}
	return fmt.Errorf("unknown Vote field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VoteMutation) AddedFields() []string {
	var fields []string
	if m.addfrom_post_id != nil {
		fields = append(fields, vote.FieldFromPostID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VoteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vote.FieldFromPostID:
		return m.AddedFromPostID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vote.FieldFromPostID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromPostID(v)
		return nil
	}
	return fmt.Errorf("unknown Vote numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VoteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vote.FieldDeletedAt) {
		fields = append(fields, vote.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VoteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VoteMutation) ClearField(name string) error {
	switch name {
	case vote.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Vote nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VoteMutation) ResetField(name string) error {
	switch name {
	case vote.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vote.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vote.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case vote.FieldFromPostID:
		m.ResetFromPostID()
		return nil
	case vote.FieldRegister:
		m.ResetRegister()
		return nil
	}
	return fmt.Errorf("unknown Vote field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VoteMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VoteMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VoteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VoteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VoteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VoteMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VoteMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Vote unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VoteMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Vote edge %s", name)
}

// VoteEventMutation represents an operation that mutates the VoteEvent nodes in the graph.
type VoteEventMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	from_role_id      *int64
	addfrom_role_id   *int64
	to_vote_id        *int64
	addto_vote_id     *int64
	to_vote_option    *int64
	addto_vote_option *int64
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*VoteEvent, error)
	predicates        []predicate.VoteEvent
}

var _ ent.Mutation = (*VoteEventMutation)(nil)

// voteeventOption allows management of the mutation configuration using functional options.
type voteeventOption func(*VoteEventMutation)

// newVoteEventMutation creates new mutation for the VoteEvent entity.
func newVoteEventMutation(c config, op Op, opts ...voteeventOption) *VoteEventMutation {
	m := &VoteEventMutation{
		config:        c,
		op:            op,
		typ:           TypeVoteEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVoteEventID sets the ID field of the mutation.
func withVoteEventID(id int64) voteeventOption {
	return func(m *VoteEventMutation) {
		var (
			err   error
			once  sync.Once
			value *VoteEvent
		)
		m.oldValue = func(ctx context.Context) (*VoteEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VoteEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVoteEvent sets the old VoteEvent of the mutation.
func withVoteEvent(node *VoteEvent) voteeventOption {
	return func(m *VoteEventMutation) {
		m.oldValue = func(context.Context) (*VoteEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VoteEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VoteEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VoteEvent entities.
func (m *VoteEventMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VoteEventMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VoteEventMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VoteEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VoteEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VoteEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VoteEvent entity.
// If the VoteEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VoteEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VoteEventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VoteEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VoteEvent entity.
// If the VoteEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VoteEventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VoteEventMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VoteEventMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the VoteEvent entity.
// If the VoteEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteEventMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *VoteEventMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[voteevent.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *VoteEventMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[voteevent.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VoteEventMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, voteevent.FieldDeletedAt)
}

// SetFromRoleID sets the "from_role_id" field.
func (m *VoteEventMutation) SetFromRoleID(i int64) {
	m.from_role_id = &i
	m.addfrom_role_id = nil
}

// FromRoleID returns the value of the "from_role_id" field in the mutation.
func (m *VoteEventMutation) FromRoleID() (r int64, exists bool) {
	v := m.from_role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromRoleID returns the old "from_role_id" field's value of the VoteEvent entity.
// If the VoteEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteEventMutation) OldFromRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromRoleID: %w", err)
	}
	return oldValue.FromRoleID, nil
}

// AddFromRoleID adds i to the "from_role_id" field.
func (m *VoteEventMutation) AddFromRoleID(i int64) {
	if m.addfrom_role_id != nil {
		*m.addfrom_role_id += i
	} else {
		m.addfrom_role_id = &i
	}
}

// AddedFromRoleID returns the value that was added to the "from_role_id" field in this mutation.
func (m *VoteEventMutation) AddedFromRoleID() (r int64, exists bool) {
	v := m.addfrom_role_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFromRoleID resets all changes to the "from_role_id" field.
func (m *VoteEventMutation) ResetFromRoleID() {
	m.from_role_id = nil
	m.addfrom_role_id = nil
}

// SetToVoteID sets the "to_vote_id" field.
func (m *VoteEventMutation) SetToVoteID(i int64) {
	m.to_vote_id = &i
	m.addto_vote_id = nil
}

// ToVoteID returns the value of the "to_vote_id" field in the mutation.
func (m *VoteEventMutation) ToVoteID() (r int64, exists bool) {
	v := m.to_vote_id
	if v == nil {
		return
	}
	return *v, true
}

// OldToVoteID returns the old "to_vote_id" field's value of the VoteEvent entity.
// If the VoteEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteEventMutation) OldToVoteID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToVoteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToVoteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToVoteID: %w", err)
	}
	return oldValue.ToVoteID, nil
}

// AddToVoteID adds i to the "to_vote_id" field.
func (m *VoteEventMutation) AddToVoteID(i int64) {
	if m.addto_vote_id != nil {
		*m.addto_vote_id += i
	} else {
		m.addto_vote_id = &i
	}
}

// AddedToVoteID returns the value that was added to the "to_vote_id" field in this mutation.
func (m *VoteEventMutation) AddedToVoteID() (r int64, exists bool) {
	v := m.addto_vote_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetToVoteID resets all changes to the "to_vote_id" field.
func (m *VoteEventMutation) ResetToVoteID() {
	m.to_vote_id = nil
	m.addto_vote_id = nil
}

// SetToVoteOption sets the "to_vote_option" field.
func (m *VoteEventMutation) SetToVoteOption(i int64) {
	m.to_vote_option = &i
	m.addto_vote_option = nil
}

// ToVoteOption returns the value of the "to_vote_option" field in the mutation.
func (m *VoteEventMutation) ToVoteOption() (r int64, exists bool) {
	v := m.to_vote_option
	if v == nil {
		return
	}
	return *v, true
}

// OldToVoteOption returns the old "to_vote_option" field's value of the VoteEvent entity.
// If the VoteEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteEventMutation) OldToVoteOption(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToVoteOption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToVoteOption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToVoteOption: %w", err)
	}
	return oldValue.ToVoteOption, nil
}

// AddToVoteOption adds i to the "to_vote_option" field.
func (m *VoteEventMutation) AddToVoteOption(i int64) {
	if m.addto_vote_option != nil {
		*m.addto_vote_option += i
	} else {
		m.addto_vote_option = &i
	}
}

// AddedToVoteOption returns the value that was added to the "to_vote_option" field in this mutation.
func (m *VoteEventMutation) AddedToVoteOption() (r int64, exists bool) {
	v := m.addto_vote_option
	if v == nil {
		return
	}
	return *v, true
}

// ResetToVoteOption resets all changes to the "to_vote_option" field.
func (m *VoteEventMutation) ResetToVoteOption() {
	m.to_vote_option = nil
	m.addto_vote_option = nil
}

// Where appends a list predicates to the VoteEventMutation builder.
func (m *VoteEventMutation) Where(ps ...predicate.VoteEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VoteEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VoteEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VoteEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VoteEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VoteEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VoteEvent).
func (m *VoteEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VoteEventMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, voteevent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, voteevent.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, voteevent.FieldDeletedAt)
	}
	if m.from_role_id != nil {
		fields = append(fields, voteevent.FieldFromRoleID)
	}
	if m.to_vote_id != nil {
		fields = append(fields, voteevent.FieldToVoteID)
	}
	if m.to_vote_option != nil {
		fields = append(fields, voteevent.FieldToVoteOption)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VoteEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case voteevent.FieldCreatedAt:
		return m.CreatedAt()
	case voteevent.FieldUpdatedAt:
		return m.UpdatedAt()
	case voteevent.FieldDeletedAt:
		return m.DeletedAt()
	case voteevent.FieldFromRoleID:
		return m.FromRoleID()
	case voteevent.FieldToVoteID:
		return m.ToVoteID()
	case voteevent.FieldToVoteOption:
		return m.ToVoteOption()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VoteEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case voteevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case voteevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case voteevent.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case voteevent.FieldFromRoleID:
		return m.OldFromRoleID(ctx)
	case voteevent.FieldToVoteID:
		return m.OldToVoteID(ctx)
	case voteevent.FieldToVoteOption:
		return m.OldToVoteOption(ctx)
	}
	return nil, fmt.Errorf("unknown VoteEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoteEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case voteevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case voteevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case voteevent.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case voteevent.FieldFromRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromRoleID(v)
		return nil
	case voteevent.FieldToVoteID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToVoteID(v)
		return nil
	case voteevent.FieldToVoteOption:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToVoteOption(v)
		return nil
	}
	return fmt.Errorf("unknown VoteEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VoteEventMutation) AddedFields() []string {
	var fields []string
	if m.addfrom_role_id != nil {
		fields = append(fields, voteevent.FieldFromRoleID)
	}
	if m.addto_vote_id != nil {
		fields = append(fields, voteevent.FieldToVoteID)
	}
	if m.addto_vote_option != nil {
		fields = append(fields, voteevent.FieldToVoteOption)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VoteEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case voteevent.FieldFromRoleID:
		return m.AddedFromRoleID()
	case voteevent.FieldToVoteID:
		return m.AddedToVoteID()
	case voteevent.FieldToVoteOption:
		return m.AddedToVoteOption()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoteEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case voteevent.FieldFromRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromRoleID(v)
		return nil
	case voteevent.FieldToVoteID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToVoteID(v)
		return nil
	case voteevent.FieldToVoteOption:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToVoteOption(v)
		return nil
	}
	return fmt.Errorf("unknown VoteEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VoteEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(voteevent.FieldDeletedAt) {
		fields = append(fields, voteevent.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VoteEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VoteEventMutation) ClearField(name string) error {
	switch name {
	case voteevent.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown VoteEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VoteEventMutation) ResetField(name string) error {
	switch name {
	case voteevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case voteevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case voteevent.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case voteevent.FieldFromRoleID:
		m.ResetFromRoleID()
		return nil
	case voteevent.FieldToVoteID:
		m.ResetToVoteID()
		return nil
	case voteevent.FieldToVoteOption:
		m.ResetToVoteOption()
		return nil
	}
	return fmt.Errorf("unknown VoteEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VoteEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VoteEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VoteEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VoteEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VoteEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VoteEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VoteEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VoteEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VoteEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VoteEvent edge %s", name)
}

// VoteOptionMutation represents an operation that mutates the VoteOption nodes in the graph.
type VoteOptionMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	vote_id       *int64
	addvote_id    *int64
	info          *string
	count         *int64
	addcount      *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*VoteOption, error)
	predicates    []predicate.VoteOption
}

var _ ent.Mutation = (*VoteOptionMutation)(nil)

// voteoptionOption allows management of the mutation configuration using functional options.
type voteoptionOption func(*VoteOptionMutation)

// newVoteOptionMutation creates new mutation for the VoteOption entity.
func newVoteOptionMutation(c config, op Op, opts ...voteoptionOption) *VoteOptionMutation {
	m := &VoteOptionMutation{
		config:        c,
		op:            op,
		typ:           TypeVoteOption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVoteOptionID sets the ID field of the mutation.
func withVoteOptionID(id int64) voteoptionOption {
	return func(m *VoteOptionMutation) {
		var (
			err   error
			once  sync.Once
			value *VoteOption
		)
		m.oldValue = func(ctx context.Context) (*VoteOption, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VoteOption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVoteOption sets the old VoteOption of the mutation.
func withVoteOption(node *VoteOption) voteoptionOption {
	return func(m *VoteOptionMutation) {
		m.oldValue = func(context.Context) (*VoteOption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VoteOptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VoteOptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VoteOption entities.
func (m *VoteOptionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VoteOptionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VoteOptionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VoteOption.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VoteOptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VoteOptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VoteOption entity.
// If the VoteOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteOptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VoteOptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VoteOptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VoteOptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VoteOption entity.
// If the VoteOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteOptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VoteOptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VoteOptionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VoteOptionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the VoteOption entity.
// If the VoteOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteOptionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *VoteOptionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[voteoption.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *VoteOptionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[voteoption.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VoteOptionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, voteoption.FieldDeletedAt)
}

// SetVoteID sets the "vote_id" field.
func (m *VoteOptionMutation) SetVoteID(i int64) {
	m.vote_id = &i
	m.addvote_id = nil
}

// VoteID returns the value of the "vote_id" field in the mutation.
func (m *VoteOptionMutation) VoteID() (r int64, exists bool) {
	v := m.vote_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVoteID returns the old "vote_id" field's value of the VoteOption entity.
// If the VoteOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteOptionMutation) OldVoteID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoteID: %w", err)
	}
	return oldValue.VoteID, nil
}

// AddVoteID adds i to the "vote_id" field.
func (m *VoteOptionMutation) AddVoteID(i int64) {
	if m.addvote_id != nil {
		*m.addvote_id += i
	} else {
		m.addvote_id = &i
	}
}

// AddedVoteID returns the value that was added to the "vote_id" field in this mutation.
func (m *VoteOptionMutation) AddedVoteID() (r int64, exists bool) {
	v := m.addvote_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetVoteID resets all changes to the "vote_id" field.
func (m *VoteOptionMutation) ResetVoteID() {
	m.vote_id = nil
	m.addvote_id = nil
}

// SetInfo sets the "info" field.
func (m *VoteOptionMutation) SetInfo(s string) {
	m.info = &s
}

// Info returns the value of the "info" field in the mutation.
func (m *VoteOptionMutation) Info() (r string, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldInfo returns the old "info" field's value of the VoteOption entity.
// If the VoteOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteOptionMutation) OldInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfo: %w", err)
	}
	return oldValue.Info, nil
}

// ResetInfo resets all changes to the "info" field.
func (m *VoteOptionMutation) ResetInfo() {
	m.info = nil
}

// SetCount sets the "count" field.
func (m *VoteOptionMutation) SetCount(i int64) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *VoteOptionMutation) Count() (r int64, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the VoteOption entity.
// If the VoteOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteOptionMutation) OldCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *VoteOptionMutation) AddCount(i int64) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *VoteOptionMutation) AddedCount() (r int64, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *VoteOptionMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// Where appends a list predicates to the VoteOptionMutation builder.
func (m *VoteOptionMutation) Where(ps ...predicate.VoteOption) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VoteOptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VoteOptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VoteOption, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VoteOptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VoteOptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VoteOption).
func (m *VoteOptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VoteOptionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, voteoption.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, voteoption.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, voteoption.FieldDeletedAt)
	}
	if m.vote_id != nil {
		fields = append(fields, voteoption.FieldVoteID)
	}
	if m.info != nil {
		fields = append(fields, voteoption.FieldInfo)
	}
	if m.count != nil {
		fields = append(fields, voteoption.FieldCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VoteOptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case voteoption.FieldCreatedAt:
		return m.CreatedAt()
	case voteoption.FieldUpdatedAt:
		return m.UpdatedAt()
	case voteoption.FieldDeletedAt:
		return m.DeletedAt()
	case voteoption.FieldVoteID:
		return m.VoteID()
	case voteoption.FieldInfo:
		return m.Info()
	case voteoption.FieldCount:
		return m.Count()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VoteOptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case voteoption.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case voteoption.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case voteoption.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case voteoption.FieldVoteID:
		return m.OldVoteID(ctx)
	case voteoption.FieldInfo:
		return m.OldInfo(ctx)
	case voteoption.FieldCount:
		return m.OldCount(ctx)
	}
	return nil, fmt.Errorf("unknown VoteOption field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoteOptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case voteoption.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case voteoption.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case voteoption.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case voteoption.FieldVoteID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoteID(v)
		return nil
	case voteoption.FieldInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfo(v)
		return nil
	case voteoption.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	}
	return fmt.Errorf("unknown VoteOption field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VoteOptionMutation) AddedFields() []string {
	var fields []string
	if m.addvote_id != nil {
		fields = append(fields, voteoption.FieldVoteID)
	}
	if m.addcount != nil {
		fields = append(fields, voteoption.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VoteOptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case voteoption.FieldVoteID:
		return m.AddedVoteID()
	case voteoption.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoteOptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case voteoption.FieldVoteID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVoteID(v)
		return nil
	case voteoption.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown VoteOption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VoteOptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(voteoption.FieldDeletedAt) {
		fields = append(fields, voteoption.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VoteOptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VoteOptionMutation) ClearField(name string) error {
	switch name {
	case voteoption.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown VoteOption nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VoteOptionMutation) ResetField(name string) error {
	switch name {
	case voteoption.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case voteoption.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case voteoption.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case voteoption.FieldVoteID:
		m.ResetVoteID()
		return nil
	case voteoption.FieldInfo:
		m.ResetInfo()
		return nil
	case voteoption.FieldCount:
		m.ResetCount()
		return nil
	}
	return fmt.Errorf("unknown VoteOption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VoteOptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VoteOptionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VoteOptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VoteOptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VoteOptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VoteOptionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VoteOptionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VoteOption unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VoteOptionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VoteOption edge %s", name)
}
