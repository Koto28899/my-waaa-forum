// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"backend/ent/migrate"

	"backend/ent/comment"
	"backend/ent/follow"
	"backend/ent/help"
	"backend/ent/notification"
	"backend/ent/post"
	"backend/ent/reply"
	"backend/ent/role"
	"backend/ent/section"
	"backend/ent/session"
	"backend/ent/star"
	"backend/ent/vote"
	"backend/ent/voteevent"
	"backend/ent/voteoption"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Comment is the client for interacting with the Comment builders.
	Comment *CommentClient
	// Follow is the client for interacting with the Follow builders.
	Follow *FollowClient
	// Help is the client for interacting with the Help builders.
	Help *HelpClient
	// Notification is the client for interacting with the Notification builders.
	Notification *NotificationClient
	// Post is the client for interacting with the Post builders.
	Post *PostClient
	// Reply is the client for interacting with the Reply builders.
	Reply *ReplyClient
	// Role is the client for interacting with the Role builders.
	Role *RoleClient
	// Section is the client for interacting with the Section builders.
	Section *SectionClient
	// Session is the client for interacting with the Session builders.
	Session *SessionClient
	// Star is the client for interacting with the Star builders.
	Star *StarClient
	// Vote is the client for interacting with the Vote builders.
	Vote *VoteClient
	// VoteEvent is the client for interacting with the VoteEvent builders.
	VoteEvent *VoteEventClient
	// VoteOption is the client for interacting with the VoteOption builders.
	VoteOption *VoteOptionClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Comment = NewCommentClient(c.config)
	c.Follow = NewFollowClient(c.config)
	c.Help = NewHelpClient(c.config)
	c.Notification = NewNotificationClient(c.config)
	c.Post = NewPostClient(c.config)
	c.Reply = NewReplyClient(c.config)
	c.Role = NewRoleClient(c.config)
	c.Section = NewSectionClient(c.config)
	c.Session = NewSessionClient(c.config)
	c.Star = NewStarClient(c.config)
	c.Vote = NewVoteClient(c.config)
	c.VoteEvent = NewVoteEventClient(c.config)
	c.VoteOption = NewVoteOptionClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:          ctx,
		config:       cfg,
		Comment:      NewCommentClient(cfg),
		Follow:       NewFollowClient(cfg),
		Help:         NewHelpClient(cfg),
		Notification: NewNotificationClient(cfg),
		Post:         NewPostClient(cfg),
		Reply:        NewReplyClient(cfg),
		Role:         NewRoleClient(cfg),
		Section:      NewSectionClient(cfg),
		Session:      NewSessionClient(cfg),
		Star:         NewStarClient(cfg),
		Vote:         NewVoteClient(cfg),
		VoteEvent:    NewVoteEventClient(cfg),
		VoteOption:   NewVoteOptionClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:          ctx,
		config:       cfg,
		Comment:      NewCommentClient(cfg),
		Follow:       NewFollowClient(cfg),
		Help:         NewHelpClient(cfg),
		Notification: NewNotificationClient(cfg),
		Post:         NewPostClient(cfg),
		Reply:        NewReplyClient(cfg),
		Role:         NewRoleClient(cfg),
		Section:      NewSectionClient(cfg),
		Session:      NewSessionClient(cfg),
		Star:         NewStarClient(cfg),
		Vote:         NewVoteClient(cfg),
		VoteEvent:    NewVoteEventClient(cfg),
		VoteOption:   NewVoteOptionClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Comment.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Comment, c.Follow, c.Help, c.Notification, c.Post, c.Reply, c.Role, c.Section,
		c.Session, c.Star, c.Vote, c.VoteEvent, c.VoteOption,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Comment, c.Follow, c.Help, c.Notification, c.Post, c.Reply, c.Role, c.Section,
		c.Session, c.Star, c.Vote, c.VoteEvent, c.VoteOption,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *CommentMutation:
		return c.Comment.mutate(ctx, m)
	case *FollowMutation:
		return c.Follow.mutate(ctx, m)
	case *HelpMutation:
		return c.Help.mutate(ctx, m)
	case *NotificationMutation:
		return c.Notification.mutate(ctx, m)
	case *PostMutation:
		return c.Post.mutate(ctx, m)
	case *ReplyMutation:
		return c.Reply.mutate(ctx, m)
	case *RoleMutation:
		return c.Role.mutate(ctx, m)
	case *SectionMutation:
		return c.Section.mutate(ctx, m)
	case *SessionMutation:
		return c.Session.mutate(ctx, m)
	case *StarMutation:
		return c.Star.mutate(ctx, m)
	case *VoteMutation:
		return c.Vote.mutate(ctx, m)
	case *VoteEventMutation:
		return c.VoteEvent.mutate(ctx, m)
	case *VoteOptionMutation:
		return c.VoteOption.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// CommentClient is a client for the Comment schema.
type CommentClient struct {
	config
}

// NewCommentClient returns a client for the Comment from the given config.
func NewCommentClient(c config) *CommentClient {
	return &CommentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `comment.Hooks(f(g(h())))`.
func (c *CommentClient) Use(hooks ...Hook) {
	c.hooks.Comment = append(c.hooks.Comment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `comment.Intercept(f(g(h())))`.
func (c *CommentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Comment = append(c.inters.Comment, interceptors...)
}

// Create returns a builder for creating a Comment entity.
func (c *CommentClient) Create() *CommentCreate {
	mutation := newCommentMutation(c.config, OpCreate)
	return &CommentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Comment entities.
func (c *CommentClient) CreateBulk(builders ...*CommentCreate) *CommentCreateBulk {
	return &CommentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CommentClient) MapCreateBulk(slice any, setFunc func(*CommentCreate, int)) *CommentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CommentCreateBulk{err: fmt.Errorf("calling to CommentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CommentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CommentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Comment.
func (c *CommentClient) Update() *CommentUpdate {
	mutation := newCommentMutation(c.config, OpUpdate)
	return &CommentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CommentClient) UpdateOne(co *Comment) *CommentUpdateOne {
	mutation := newCommentMutation(c.config, OpUpdateOne, withComment(co))
	return &CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CommentClient) UpdateOneID(id int64) *CommentUpdateOne {
	mutation := newCommentMutation(c.config, OpUpdateOne, withCommentID(id))
	return &CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Comment.
func (c *CommentClient) Delete() *CommentDelete {
	mutation := newCommentMutation(c.config, OpDelete)
	return &CommentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CommentClient) DeleteOne(co *Comment) *CommentDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CommentClient) DeleteOneID(id int64) *CommentDeleteOne {
	builder := c.Delete().Where(comment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CommentDeleteOne{builder}
}

// Query returns a query builder for Comment.
func (c *CommentClient) Query() *CommentQuery {
	return &CommentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeComment},
		inters: c.Interceptors(),
	}
}

// Get returns a Comment entity by its id.
func (c *CommentClient) Get(ctx context.Context, id int64) (*Comment, error) {
	return c.Query().Where(comment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CommentClient) GetX(ctx context.Context, id int64) *Comment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CommentClient) Hooks() []Hook {
	return c.hooks.Comment
}

// Interceptors returns the client interceptors.
func (c *CommentClient) Interceptors() []Interceptor {
	return c.inters.Comment
}

func (c *CommentClient) mutate(ctx context.Context, m *CommentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CommentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CommentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CommentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Comment mutation op: %q", m.Op())
	}
}

// FollowClient is a client for the Follow schema.
type FollowClient struct {
	config
}

// NewFollowClient returns a client for the Follow from the given config.
func NewFollowClient(c config) *FollowClient {
	return &FollowClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `follow.Hooks(f(g(h())))`.
func (c *FollowClient) Use(hooks ...Hook) {
	c.hooks.Follow = append(c.hooks.Follow, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `follow.Intercept(f(g(h())))`.
func (c *FollowClient) Intercept(interceptors ...Interceptor) {
	c.inters.Follow = append(c.inters.Follow, interceptors...)
}

// Create returns a builder for creating a Follow entity.
func (c *FollowClient) Create() *FollowCreate {
	mutation := newFollowMutation(c.config, OpCreate)
	return &FollowCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Follow entities.
func (c *FollowClient) CreateBulk(builders ...*FollowCreate) *FollowCreateBulk {
	return &FollowCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FollowClient) MapCreateBulk(slice any, setFunc func(*FollowCreate, int)) *FollowCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FollowCreateBulk{err: fmt.Errorf("calling to FollowClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FollowCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FollowCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Follow.
func (c *FollowClient) Update() *FollowUpdate {
	mutation := newFollowMutation(c.config, OpUpdate)
	return &FollowUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FollowClient) UpdateOne(f *Follow) *FollowUpdateOne {
	mutation := newFollowMutation(c.config, OpUpdateOne, withFollow(f))
	return &FollowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FollowClient) UpdateOneID(id int64) *FollowUpdateOne {
	mutation := newFollowMutation(c.config, OpUpdateOne, withFollowID(id))
	return &FollowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Follow.
func (c *FollowClient) Delete() *FollowDelete {
	mutation := newFollowMutation(c.config, OpDelete)
	return &FollowDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FollowClient) DeleteOne(f *Follow) *FollowDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FollowClient) DeleteOneID(id int64) *FollowDeleteOne {
	builder := c.Delete().Where(follow.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FollowDeleteOne{builder}
}

// Query returns a query builder for Follow.
func (c *FollowClient) Query() *FollowQuery {
	return &FollowQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFollow},
		inters: c.Interceptors(),
	}
}

// Get returns a Follow entity by its id.
func (c *FollowClient) Get(ctx context.Context, id int64) (*Follow, error) {
	return c.Query().Where(follow.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FollowClient) GetX(ctx context.Context, id int64) *Follow {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FollowClient) Hooks() []Hook {
	return c.hooks.Follow
}

// Interceptors returns the client interceptors.
func (c *FollowClient) Interceptors() []Interceptor {
	return c.inters.Follow
}

func (c *FollowClient) mutate(ctx context.Context, m *FollowMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FollowCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FollowUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FollowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FollowDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Follow mutation op: %q", m.Op())
	}
}

// HelpClient is a client for the Help schema.
type HelpClient struct {
	config
}

// NewHelpClient returns a client for the Help from the given config.
func NewHelpClient(c config) *HelpClient {
	return &HelpClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `help.Hooks(f(g(h())))`.
func (c *HelpClient) Use(hooks ...Hook) {
	c.hooks.Help = append(c.hooks.Help, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `help.Intercept(f(g(h())))`.
func (c *HelpClient) Intercept(interceptors ...Interceptor) {
	c.inters.Help = append(c.inters.Help, interceptors...)
}

// Create returns a builder for creating a Help entity.
func (c *HelpClient) Create() *HelpCreate {
	mutation := newHelpMutation(c.config, OpCreate)
	return &HelpCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Help entities.
func (c *HelpClient) CreateBulk(builders ...*HelpCreate) *HelpCreateBulk {
	return &HelpCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HelpClient) MapCreateBulk(slice any, setFunc func(*HelpCreate, int)) *HelpCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HelpCreateBulk{err: fmt.Errorf("calling to HelpClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HelpCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HelpCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Help.
func (c *HelpClient) Update() *HelpUpdate {
	mutation := newHelpMutation(c.config, OpUpdate)
	return &HelpUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HelpClient) UpdateOne(h *Help) *HelpUpdateOne {
	mutation := newHelpMutation(c.config, OpUpdateOne, withHelp(h))
	return &HelpUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HelpClient) UpdateOneID(id int64) *HelpUpdateOne {
	mutation := newHelpMutation(c.config, OpUpdateOne, withHelpID(id))
	return &HelpUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Help.
func (c *HelpClient) Delete() *HelpDelete {
	mutation := newHelpMutation(c.config, OpDelete)
	return &HelpDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HelpClient) DeleteOne(h *Help) *HelpDeleteOne {
	return c.DeleteOneID(h.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HelpClient) DeleteOneID(id int64) *HelpDeleteOne {
	builder := c.Delete().Where(help.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HelpDeleteOne{builder}
}

// Query returns a query builder for Help.
func (c *HelpClient) Query() *HelpQuery {
	return &HelpQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHelp},
		inters: c.Interceptors(),
	}
}

// Get returns a Help entity by its id.
func (c *HelpClient) Get(ctx context.Context, id int64) (*Help, error) {
	return c.Query().Where(help.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HelpClient) GetX(ctx context.Context, id int64) *Help {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *HelpClient) Hooks() []Hook {
	return c.hooks.Help
}

// Interceptors returns the client interceptors.
func (c *HelpClient) Interceptors() []Interceptor {
	return c.inters.Help
}

func (c *HelpClient) mutate(ctx context.Context, m *HelpMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HelpCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HelpUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HelpUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HelpDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Help mutation op: %q", m.Op())
	}
}

// NotificationClient is a client for the Notification schema.
type NotificationClient struct {
	config
}

// NewNotificationClient returns a client for the Notification from the given config.
func NewNotificationClient(c config) *NotificationClient {
	return &NotificationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `notification.Hooks(f(g(h())))`.
func (c *NotificationClient) Use(hooks ...Hook) {
	c.hooks.Notification = append(c.hooks.Notification, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `notification.Intercept(f(g(h())))`.
func (c *NotificationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Notification = append(c.inters.Notification, interceptors...)
}

// Create returns a builder for creating a Notification entity.
func (c *NotificationClient) Create() *NotificationCreate {
	mutation := newNotificationMutation(c.config, OpCreate)
	return &NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Notification entities.
func (c *NotificationClient) CreateBulk(builders ...*NotificationCreate) *NotificationCreateBulk {
	return &NotificationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NotificationClient) MapCreateBulk(slice any, setFunc func(*NotificationCreate, int)) *NotificationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NotificationCreateBulk{err: fmt.Errorf("calling to NotificationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NotificationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NotificationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Notification.
func (c *NotificationClient) Update() *NotificationUpdate {
	mutation := newNotificationMutation(c.config, OpUpdate)
	return &NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NotificationClient) UpdateOne(n *Notification) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotification(n))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NotificationClient) UpdateOneID(id int64) *NotificationUpdateOne {
	mutation := newNotificationMutation(c.config, OpUpdateOne, withNotificationID(id))
	return &NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Notification.
func (c *NotificationClient) Delete() *NotificationDelete {
	mutation := newNotificationMutation(c.config, OpDelete)
	return &NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NotificationClient) DeleteOne(n *Notification) *NotificationDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NotificationClient) DeleteOneID(id int64) *NotificationDeleteOne {
	builder := c.Delete().Where(notification.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NotificationDeleteOne{builder}
}

// Query returns a query builder for Notification.
func (c *NotificationClient) Query() *NotificationQuery {
	return &NotificationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNotification},
		inters: c.Interceptors(),
	}
}

// Get returns a Notification entity by its id.
func (c *NotificationClient) Get(ctx context.Context, id int64) (*Notification, error) {
	return c.Query().Where(notification.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NotificationClient) GetX(ctx context.Context, id int64) *Notification {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *NotificationClient) Hooks() []Hook {
	return c.hooks.Notification
}

// Interceptors returns the client interceptors.
func (c *NotificationClient) Interceptors() []Interceptor {
	return c.inters.Notification
}

func (c *NotificationClient) mutate(ctx context.Context, m *NotificationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NotificationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NotificationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NotificationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NotificationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Notification mutation op: %q", m.Op())
	}
}

// PostClient is a client for the Post schema.
type PostClient struct {
	config
}

// NewPostClient returns a client for the Post from the given config.
func NewPostClient(c config) *PostClient {
	return &PostClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `post.Hooks(f(g(h())))`.
func (c *PostClient) Use(hooks ...Hook) {
	c.hooks.Post = append(c.hooks.Post, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `post.Intercept(f(g(h())))`.
func (c *PostClient) Intercept(interceptors ...Interceptor) {
	c.inters.Post = append(c.inters.Post, interceptors...)
}

// Create returns a builder for creating a Post entity.
func (c *PostClient) Create() *PostCreate {
	mutation := newPostMutation(c.config, OpCreate)
	return &PostCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Post entities.
func (c *PostClient) CreateBulk(builders ...*PostCreate) *PostCreateBulk {
	return &PostCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PostClient) MapCreateBulk(slice any, setFunc func(*PostCreate, int)) *PostCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PostCreateBulk{err: fmt.Errorf("calling to PostClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PostCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PostCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Post.
func (c *PostClient) Update() *PostUpdate {
	mutation := newPostMutation(c.config, OpUpdate)
	return &PostUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PostClient) UpdateOne(po *Post) *PostUpdateOne {
	mutation := newPostMutation(c.config, OpUpdateOne, withPost(po))
	return &PostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PostClient) UpdateOneID(id int64) *PostUpdateOne {
	mutation := newPostMutation(c.config, OpUpdateOne, withPostID(id))
	return &PostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Post.
func (c *PostClient) Delete() *PostDelete {
	mutation := newPostMutation(c.config, OpDelete)
	return &PostDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PostClient) DeleteOne(po *Post) *PostDeleteOne {
	return c.DeleteOneID(po.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PostClient) DeleteOneID(id int64) *PostDeleteOne {
	builder := c.Delete().Where(post.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PostDeleteOne{builder}
}

// Query returns a query builder for Post.
func (c *PostClient) Query() *PostQuery {
	return &PostQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePost},
		inters: c.Interceptors(),
	}
}

// Get returns a Post entity by its id.
func (c *PostClient) Get(ctx context.Context, id int64) (*Post, error) {
	return c.Query().Where(post.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PostClient) GetX(ctx context.Context, id int64) *Post {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PostClient) Hooks() []Hook {
	return c.hooks.Post
}

// Interceptors returns the client interceptors.
func (c *PostClient) Interceptors() []Interceptor {
	return c.inters.Post
}

func (c *PostClient) mutate(ctx context.Context, m *PostMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PostCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PostUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PostDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Post mutation op: %q", m.Op())
	}
}

// ReplyClient is a client for the Reply schema.
type ReplyClient struct {
	config
}

// NewReplyClient returns a client for the Reply from the given config.
func NewReplyClient(c config) *ReplyClient {
	return &ReplyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reply.Hooks(f(g(h())))`.
func (c *ReplyClient) Use(hooks ...Hook) {
	c.hooks.Reply = append(c.hooks.Reply, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `reply.Intercept(f(g(h())))`.
func (c *ReplyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Reply = append(c.inters.Reply, interceptors...)
}

// Create returns a builder for creating a Reply entity.
func (c *ReplyClient) Create() *ReplyCreate {
	mutation := newReplyMutation(c.config, OpCreate)
	return &ReplyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Reply entities.
func (c *ReplyClient) CreateBulk(builders ...*ReplyCreate) *ReplyCreateBulk {
	return &ReplyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ReplyClient) MapCreateBulk(slice any, setFunc func(*ReplyCreate, int)) *ReplyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ReplyCreateBulk{err: fmt.Errorf("calling to ReplyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ReplyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ReplyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Reply.
func (c *ReplyClient) Update() *ReplyUpdate {
	mutation := newReplyMutation(c.config, OpUpdate)
	return &ReplyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReplyClient) UpdateOne(r *Reply) *ReplyUpdateOne {
	mutation := newReplyMutation(c.config, OpUpdateOne, withReply(r))
	return &ReplyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReplyClient) UpdateOneID(id int64) *ReplyUpdateOne {
	mutation := newReplyMutation(c.config, OpUpdateOne, withReplyID(id))
	return &ReplyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Reply.
func (c *ReplyClient) Delete() *ReplyDelete {
	mutation := newReplyMutation(c.config, OpDelete)
	return &ReplyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReplyClient) DeleteOne(r *Reply) *ReplyDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReplyClient) DeleteOneID(id int64) *ReplyDeleteOne {
	builder := c.Delete().Where(reply.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReplyDeleteOne{builder}
}

// Query returns a query builder for Reply.
func (c *ReplyClient) Query() *ReplyQuery {
	return &ReplyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReply},
		inters: c.Interceptors(),
	}
}

// Get returns a Reply entity by its id.
func (c *ReplyClient) Get(ctx context.Context, id int64) (*Reply, error) {
	return c.Query().Where(reply.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReplyClient) GetX(ctx context.Context, id int64) *Reply {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ReplyClient) Hooks() []Hook {
	return c.hooks.Reply
}

// Interceptors returns the client interceptors.
func (c *ReplyClient) Interceptors() []Interceptor {
	return c.inters.Reply
}

func (c *ReplyClient) mutate(ctx context.Context, m *ReplyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReplyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReplyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReplyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReplyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Reply mutation op: %q", m.Op())
	}
}

// RoleClient is a client for the Role schema.
type RoleClient struct {
	config
}

// NewRoleClient returns a client for the Role from the given config.
func NewRoleClient(c config) *RoleClient {
	return &RoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role.Hooks(f(g(h())))`.
func (c *RoleClient) Use(hooks ...Hook) {
	c.hooks.Role = append(c.hooks.Role, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `role.Intercept(f(g(h())))`.
func (c *RoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Role = append(c.inters.Role, interceptors...)
}

// Create returns a builder for creating a Role entity.
func (c *RoleClient) Create() *RoleCreate {
	mutation := newRoleMutation(c.config, OpCreate)
	return &RoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Role entities.
func (c *RoleClient) CreateBulk(builders ...*RoleCreate) *RoleCreateBulk {
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoleClient) MapCreateBulk(slice any, setFunc func(*RoleCreate, int)) *RoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoleCreateBulk{err: fmt.Errorf("calling to RoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Role.
func (c *RoleClient) Update() *RoleUpdate {
	mutation := newRoleMutation(c.config, OpUpdate)
	return &RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleClient) UpdateOne(r *Role) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRole(r))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleClient) UpdateOneID(id int64) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRoleID(id))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role.
func (c *RoleClient) Delete() *RoleDelete {
	mutation := newRoleMutation(c.config, OpDelete)
	return &RoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleClient) DeleteOne(r *Role) *RoleDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleClient) DeleteOneID(id int64) *RoleDeleteOne {
	builder := c.Delete().Where(role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleDeleteOne{builder}
}

// Query returns a query builder for Role.
func (c *RoleClient) Query() *RoleQuery {
	return &RoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRole},
		inters: c.Interceptors(),
	}
}

// Get returns a Role entity by its id.
func (c *RoleClient) Get(ctx context.Context, id int64) (*Role, error) {
	return c.Query().Where(role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleClient) GetX(ctx context.Context, id int64) *Role {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RoleClient) Hooks() []Hook {
	return c.hooks.Role
}

// Interceptors returns the client interceptors.
func (c *RoleClient) Interceptors() []Interceptor {
	return c.inters.Role
}

func (c *RoleClient) mutate(ctx context.Context, m *RoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Role mutation op: %q", m.Op())
	}
}

// SectionClient is a client for the Section schema.
type SectionClient struct {
	config
}

// NewSectionClient returns a client for the Section from the given config.
func NewSectionClient(c config) *SectionClient {
	return &SectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `section.Hooks(f(g(h())))`.
func (c *SectionClient) Use(hooks ...Hook) {
	c.hooks.Section = append(c.hooks.Section, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `section.Intercept(f(g(h())))`.
func (c *SectionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Section = append(c.inters.Section, interceptors...)
}

// Create returns a builder for creating a Section entity.
func (c *SectionClient) Create() *SectionCreate {
	mutation := newSectionMutation(c.config, OpCreate)
	return &SectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Section entities.
func (c *SectionClient) CreateBulk(builders ...*SectionCreate) *SectionCreateBulk {
	return &SectionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SectionClient) MapCreateBulk(slice any, setFunc func(*SectionCreate, int)) *SectionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SectionCreateBulk{err: fmt.Errorf("calling to SectionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SectionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Section.
func (c *SectionClient) Update() *SectionUpdate {
	mutation := newSectionMutation(c.config, OpUpdate)
	return &SectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SectionClient) UpdateOne(s *Section) *SectionUpdateOne {
	mutation := newSectionMutation(c.config, OpUpdateOne, withSection(s))
	return &SectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SectionClient) UpdateOneID(id int64) *SectionUpdateOne {
	mutation := newSectionMutation(c.config, OpUpdateOne, withSectionID(id))
	return &SectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Section.
func (c *SectionClient) Delete() *SectionDelete {
	mutation := newSectionMutation(c.config, OpDelete)
	return &SectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SectionClient) DeleteOne(s *Section) *SectionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SectionClient) DeleteOneID(id int64) *SectionDeleteOne {
	builder := c.Delete().Where(section.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SectionDeleteOne{builder}
}

// Query returns a query builder for Section.
func (c *SectionClient) Query() *SectionQuery {
	return &SectionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSection},
		inters: c.Interceptors(),
	}
}

// Get returns a Section entity by its id.
func (c *SectionClient) Get(ctx context.Context, id int64) (*Section, error) {
	return c.Query().Where(section.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SectionClient) GetX(ctx context.Context, id int64) *Section {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SectionClient) Hooks() []Hook {
	return c.hooks.Section
}

// Interceptors returns the client interceptors.
func (c *SectionClient) Interceptors() []Interceptor {
	return c.inters.Section
}

func (c *SectionClient) mutate(ctx context.Context, m *SectionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SectionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SectionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SectionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Section mutation op: %q", m.Op())
	}
}

// SessionClient is a client for the Session schema.
type SessionClient struct {
	config
}

// NewSessionClient returns a client for the Session from the given config.
func NewSessionClient(c config) *SessionClient {
	return &SessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `session.Hooks(f(g(h())))`.
func (c *SessionClient) Use(hooks ...Hook) {
	c.hooks.Session = append(c.hooks.Session, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `session.Intercept(f(g(h())))`.
func (c *SessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Session = append(c.inters.Session, interceptors...)
}

// Create returns a builder for creating a Session entity.
func (c *SessionClient) Create() *SessionCreate {
	mutation := newSessionMutation(c.config, OpCreate)
	return &SessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Session entities.
func (c *SessionClient) CreateBulk(builders ...*SessionCreate) *SessionCreateBulk {
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SessionClient) MapCreateBulk(slice any, setFunc func(*SessionCreate, int)) *SessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SessionCreateBulk{err: fmt.Errorf("calling to SessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Session.
func (c *SessionClient) Update() *SessionUpdate {
	mutation := newSessionMutation(c.config, OpUpdate)
	return &SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionClient) UpdateOne(s *Session) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSession(s))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionClient) UpdateOneID(id uuid.UUID) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSessionID(id))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Session.
func (c *SessionClient) Delete() *SessionDelete {
	mutation := newSessionMutation(c.config, OpDelete)
	return &SessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SessionClient) DeleteOne(s *Session) *SessionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SessionClient) DeleteOneID(id uuid.UUID) *SessionDeleteOne {
	builder := c.Delete().Where(session.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionDeleteOne{builder}
}

// Query returns a query builder for Session.
func (c *SessionClient) Query() *SessionQuery {
	return &SessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSession},
		inters: c.Interceptors(),
	}
}

// Get returns a Session entity by its id.
func (c *SessionClient) Get(ctx context.Context, id uuid.UUID) (*Session, error) {
	return c.Query().Where(session.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionClient) GetX(ctx context.Context, id uuid.UUID) *Session {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SessionClient) Hooks() []Hook {
	return c.hooks.Session
}

// Interceptors returns the client interceptors.
func (c *SessionClient) Interceptors() []Interceptor {
	return c.inters.Session
}

func (c *SessionClient) mutate(ctx context.Context, m *SessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Session mutation op: %q", m.Op())
	}
}

// StarClient is a client for the Star schema.
type StarClient struct {
	config
}

// NewStarClient returns a client for the Star from the given config.
func NewStarClient(c config) *StarClient {
	return &StarClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `star.Hooks(f(g(h())))`.
func (c *StarClient) Use(hooks ...Hook) {
	c.hooks.Star = append(c.hooks.Star, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `star.Intercept(f(g(h())))`.
func (c *StarClient) Intercept(interceptors ...Interceptor) {
	c.inters.Star = append(c.inters.Star, interceptors...)
}

// Create returns a builder for creating a Star entity.
func (c *StarClient) Create() *StarCreate {
	mutation := newStarMutation(c.config, OpCreate)
	return &StarCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Star entities.
func (c *StarClient) CreateBulk(builders ...*StarCreate) *StarCreateBulk {
	return &StarCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StarClient) MapCreateBulk(slice any, setFunc func(*StarCreate, int)) *StarCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StarCreateBulk{err: fmt.Errorf("calling to StarClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StarCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StarCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Star.
func (c *StarClient) Update() *StarUpdate {
	mutation := newStarMutation(c.config, OpUpdate)
	return &StarUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StarClient) UpdateOne(s *Star) *StarUpdateOne {
	mutation := newStarMutation(c.config, OpUpdateOne, withStar(s))
	return &StarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StarClient) UpdateOneID(id int64) *StarUpdateOne {
	mutation := newStarMutation(c.config, OpUpdateOne, withStarID(id))
	return &StarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Star.
func (c *StarClient) Delete() *StarDelete {
	mutation := newStarMutation(c.config, OpDelete)
	return &StarDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StarClient) DeleteOne(s *Star) *StarDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StarClient) DeleteOneID(id int64) *StarDeleteOne {
	builder := c.Delete().Where(star.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StarDeleteOne{builder}
}

// Query returns a query builder for Star.
func (c *StarClient) Query() *StarQuery {
	return &StarQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStar},
		inters: c.Interceptors(),
	}
}

// Get returns a Star entity by its id.
func (c *StarClient) Get(ctx context.Context, id int64) (*Star, error) {
	return c.Query().Where(star.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StarClient) GetX(ctx context.Context, id int64) *Star {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *StarClient) Hooks() []Hook {
	return c.hooks.Star
}

// Interceptors returns the client interceptors.
func (c *StarClient) Interceptors() []Interceptor {
	return c.inters.Star
}

func (c *StarClient) mutate(ctx context.Context, m *StarMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StarCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StarUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StarDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Star mutation op: %q", m.Op())
	}
}

// VoteClient is a client for the Vote schema.
type VoteClient struct {
	config
}

// NewVoteClient returns a client for the Vote from the given config.
func NewVoteClient(c config) *VoteClient {
	return &VoteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vote.Hooks(f(g(h())))`.
func (c *VoteClient) Use(hooks ...Hook) {
	c.hooks.Vote = append(c.hooks.Vote, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vote.Intercept(f(g(h())))`.
func (c *VoteClient) Intercept(interceptors ...Interceptor) {
	c.inters.Vote = append(c.inters.Vote, interceptors...)
}

// Create returns a builder for creating a Vote entity.
func (c *VoteClient) Create() *VoteCreate {
	mutation := newVoteMutation(c.config, OpCreate)
	return &VoteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Vote entities.
func (c *VoteClient) CreateBulk(builders ...*VoteCreate) *VoteCreateBulk {
	return &VoteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VoteClient) MapCreateBulk(slice any, setFunc func(*VoteCreate, int)) *VoteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VoteCreateBulk{err: fmt.Errorf("calling to VoteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VoteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VoteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Vote.
func (c *VoteClient) Update() *VoteUpdate {
	mutation := newVoteMutation(c.config, OpUpdate)
	return &VoteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VoteClient) UpdateOne(v *Vote) *VoteUpdateOne {
	mutation := newVoteMutation(c.config, OpUpdateOne, withVote(v))
	return &VoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VoteClient) UpdateOneID(id int64) *VoteUpdateOne {
	mutation := newVoteMutation(c.config, OpUpdateOne, withVoteID(id))
	return &VoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Vote.
func (c *VoteClient) Delete() *VoteDelete {
	mutation := newVoteMutation(c.config, OpDelete)
	return &VoteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VoteClient) DeleteOne(v *Vote) *VoteDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VoteClient) DeleteOneID(id int64) *VoteDeleteOne {
	builder := c.Delete().Where(vote.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VoteDeleteOne{builder}
}

// Query returns a query builder for Vote.
func (c *VoteClient) Query() *VoteQuery {
	return &VoteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVote},
		inters: c.Interceptors(),
	}
}

// Get returns a Vote entity by its id.
func (c *VoteClient) Get(ctx context.Context, id int64) (*Vote, error) {
	return c.Query().Where(vote.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VoteClient) GetX(ctx context.Context, id int64) *Vote {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VoteClient) Hooks() []Hook {
	return c.hooks.Vote
}

// Interceptors returns the client interceptors.
func (c *VoteClient) Interceptors() []Interceptor {
	return c.inters.Vote
}

func (c *VoteClient) mutate(ctx context.Context, m *VoteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VoteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VoteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VoteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Vote mutation op: %q", m.Op())
	}
}

// VoteEventClient is a client for the VoteEvent schema.
type VoteEventClient struct {
	config
}

// NewVoteEventClient returns a client for the VoteEvent from the given config.
func NewVoteEventClient(c config) *VoteEventClient {
	return &VoteEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `voteevent.Hooks(f(g(h())))`.
func (c *VoteEventClient) Use(hooks ...Hook) {
	c.hooks.VoteEvent = append(c.hooks.VoteEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `voteevent.Intercept(f(g(h())))`.
func (c *VoteEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.VoteEvent = append(c.inters.VoteEvent, interceptors...)
}

// Create returns a builder for creating a VoteEvent entity.
func (c *VoteEventClient) Create() *VoteEventCreate {
	mutation := newVoteEventMutation(c.config, OpCreate)
	return &VoteEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VoteEvent entities.
func (c *VoteEventClient) CreateBulk(builders ...*VoteEventCreate) *VoteEventCreateBulk {
	return &VoteEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VoteEventClient) MapCreateBulk(slice any, setFunc func(*VoteEventCreate, int)) *VoteEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VoteEventCreateBulk{err: fmt.Errorf("calling to VoteEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VoteEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VoteEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VoteEvent.
func (c *VoteEventClient) Update() *VoteEventUpdate {
	mutation := newVoteEventMutation(c.config, OpUpdate)
	return &VoteEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VoteEventClient) UpdateOne(ve *VoteEvent) *VoteEventUpdateOne {
	mutation := newVoteEventMutation(c.config, OpUpdateOne, withVoteEvent(ve))
	return &VoteEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VoteEventClient) UpdateOneID(id int64) *VoteEventUpdateOne {
	mutation := newVoteEventMutation(c.config, OpUpdateOne, withVoteEventID(id))
	return &VoteEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VoteEvent.
func (c *VoteEventClient) Delete() *VoteEventDelete {
	mutation := newVoteEventMutation(c.config, OpDelete)
	return &VoteEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VoteEventClient) DeleteOne(ve *VoteEvent) *VoteEventDeleteOne {
	return c.DeleteOneID(ve.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VoteEventClient) DeleteOneID(id int64) *VoteEventDeleteOne {
	builder := c.Delete().Where(voteevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VoteEventDeleteOne{builder}
}

// Query returns a query builder for VoteEvent.
func (c *VoteEventClient) Query() *VoteEventQuery {
	return &VoteEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVoteEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a VoteEvent entity by its id.
func (c *VoteEventClient) Get(ctx context.Context, id int64) (*VoteEvent, error) {
	return c.Query().Where(voteevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VoteEventClient) GetX(ctx context.Context, id int64) *VoteEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VoteEventClient) Hooks() []Hook {
	return c.hooks.VoteEvent
}

// Interceptors returns the client interceptors.
func (c *VoteEventClient) Interceptors() []Interceptor {
	return c.inters.VoteEvent
}

func (c *VoteEventClient) mutate(ctx context.Context, m *VoteEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VoteEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VoteEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VoteEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VoteEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VoteEvent mutation op: %q", m.Op())
	}
}

// VoteOptionClient is a client for the VoteOption schema.
type VoteOptionClient struct {
	config
}

// NewVoteOptionClient returns a client for the VoteOption from the given config.
func NewVoteOptionClient(c config) *VoteOptionClient {
	return &VoteOptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `voteoption.Hooks(f(g(h())))`.
func (c *VoteOptionClient) Use(hooks ...Hook) {
	c.hooks.VoteOption = append(c.hooks.VoteOption, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `voteoption.Intercept(f(g(h())))`.
func (c *VoteOptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.VoteOption = append(c.inters.VoteOption, interceptors...)
}

// Create returns a builder for creating a VoteOption entity.
func (c *VoteOptionClient) Create() *VoteOptionCreate {
	mutation := newVoteOptionMutation(c.config, OpCreate)
	return &VoteOptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VoteOption entities.
func (c *VoteOptionClient) CreateBulk(builders ...*VoteOptionCreate) *VoteOptionCreateBulk {
	return &VoteOptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VoteOptionClient) MapCreateBulk(slice any, setFunc func(*VoteOptionCreate, int)) *VoteOptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VoteOptionCreateBulk{err: fmt.Errorf("calling to VoteOptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VoteOptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VoteOptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VoteOption.
func (c *VoteOptionClient) Update() *VoteOptionUpdate {
	mutation := newVoteOptionMutation(c.config, OpUpdate)
	return &VoteOptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VoteOptionClient) UpdateOne(vo *VoteOption) *VoteOptionUpdateOne {
	mutation := newVoteOptionMutation(c.config, OpUpdateOne, withVoteOption(vo))
	return &VoteOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VoteOptionClient) UpdateOneID(id int64) *VoteOptionUpdateOne {
	mutation := newVoteOptionMutation(c.config, OpUpdateOne, withVoteOptionID(id))
	return &VoteOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VoteOption.
func (c *VoteOptionClient) Delete() *VoteOptionDelete {
	mutation := newVoteOptionMutation(c.config, OpDelete)
	return &VoteOptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VoteOptionClient) DeleteOne(vo *VoteOption) *VoteOptionDeleteOne {
	return c.DeleteOneID(vo.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VoteOptionClient) DeleteOneID(id int64) *VoteOptionDeleteOne {
	builder := c.Delete().Where(voteoption.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VoteOptionDeleteOne{builder}
}

// Query returns a query builder for VoteOption.
func (c *VoteOptionClient) Query() *VoteOptionQuery {
	return &VoteOptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVoteOption},
		inters: c.Interceptors(),
	}
}

// Get returns a VoteOption entity by its id.
func (c *VoteOptionClient) Get(ctx context.Context, id int64) (*VoteOption, error) {
	return c.Query().Where(voteoption.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VoteOptionClient) GetX(ctx context.Context, id int64) *VoteOption {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VoteOptionClient) Hooks() []Hook {
	return c.hooks.VoteOption
}

// Interceptors returns the client interceptors.
func (c *VoteOptionClient) Interceptors() []Interceptor {
	return c.inters.VoteOption
}

func (c *VoteOptionClient) mutate(ctx context.Context, m *VoteOptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VoteOptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VoteOptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VoteOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VoteOptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VoteOption mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Comment, Follow, Help, Notification, Post, Reply, Role, Section, Session, Star,
		Vote, VoteEvent, VoteOption []ent.Hook
	}
	inters struct {
		Comment, Follow, Help, Notification, Post, Reply, Role, Section, Session, Star,
		Vote, VoteEvent, VoteOption []ent.Interceptor
	}
)
